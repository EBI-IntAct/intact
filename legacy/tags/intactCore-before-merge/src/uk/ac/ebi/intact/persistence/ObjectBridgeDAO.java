/*
Copyright (c) 2002 The European Bioinformatics Institute, and others.
All rights reserved. Please see the file LICENSE
in the root directory of this distribution.
*/

package uk.ac.ebi.intact.persistence;

import org.apache.log4j.Logger;
import org.apache.ojb.broker.*;
import org.apache.ojb.broker.accesslayer.LookupException;
import org.apache.ojb.broker.accesslayer.OJBIterator;
import org.apache.ojb.broker.metadata.*;
import org.apache.ojb.broker.metadata.fieldaccess.PersistentField;
import org.apache.ojb.broker.query.*;
import org.apache.ojb.broker.util.ObjectModificationDefaultImpl;
import org.apache.ojb.odmg.OJB;
import org.apache.ojb.odmg.TransactionImpl;
import org.odmg.Database;
import org.odmg.Implementation;
import org.odmg.ODMGException;
import org.odmg.Transaction;
import uk.ac.ebi.intact.business.BusinessConstants;
import uk.ac.ebi.intact.model.proxy.IntactObjectProxy;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.util.*;

/**
 *  <p>This class provides an ObjectBridge-specific Data Access Object, which
 * effectively wraps up an ObjectBridge broker object. Note that this DAO only
 * provides a wrapped object from the ObjectBridge kernel, NOT the ODMG interface.</p>
 *
 * @author Chris Lewington, Sugath Mudali
 * @version $Id$
 */

public class ObjectBridgeDAO implements DAO {

    public static final String OJB_LOGGER_NAME = "ojb";

    /**
     *  holds the instance of the Database (ie a connection)
     * NB this is not serializable!!
     */
    private PersistenceBroker broker;

    /**
     * A log utility, used if required
     */
    private Logger logger;

    /** cache to be used for caching by unique search parameters. The parameter
     * is the key, and the value is the key used by the OJB cache.
     *
     */
    private HashMap cache = new HashMap();

    /** determines which classes are to be cached.
     *
     */
    private HashSet cachedClasses = new HashSet();

    /**
     * ODMG factory instance used to get DB instances
     */
    private Implementation odmg;

    /**
     * an ODMG DB instance
     */
    private Database db;

    /**
     * ODMG transaction
     */
    private Transaction tx;

    /**
     * OJB repository file (contains mappings).
     */
    private String repositoryFile;

    /**
     * The user name to access the database.
     */
    private String user;

    /**
     * The password to access the database.
     */
    private String password;

    /**
     * defines the 'no-op' value for a transaction type (reset to this
     * after each transaction commits or rolls back)
     */
    private static final int NULL_TX_TYPE = -999999;

    /**
     * defines the current transaction type - defaults to JDBC
     * in begin unless object level specified. Initialised to
     * an 'unknown' value
     */
    private int transactionType = NULL_TX_TYPE;

    //used to save connection info in ODMG format
    private String connectionDetails;


    public ObjectBridgeDAO(PersistenceBroker broker) {
        this.broker = broker;

        //alias instead of repositoryfile name
        repositoryFile = broker.getPBKey().getAlias();

        //get user details and cache for later use
        user = broker.getPBKey().getUser();
        password = broker.getPBKey().getPassword();

        // set up the logging facilities
        logger = Logger.getLogger(OJB_LOGGER_NAME);

        //now also set up some ODMG stuff for operations needing
        //transaction control and locking (eg write/update)
        odmg = OJB.getInstance();
        db = odmg.newDatabase();

        //connect using the user details supplied to the broker
        //NB ODMG expects jcdAlias, user, password to be seperated by #
        PBKey defaultKey = MetadataManager.getInstance().getDefaultPBKey();
        connectionDetails = defaultKey.getAlias() + "#" + user + "#" + password;
        try {
            db.open(connectionDetails, Database.OPEN_READ_WRITE);
        }
        catch (ODMGException e) {
            logger.error("failed to open database!!", e);
        }
    }

    /**
     * Method to release result resources (eg result set). An IllegalArgumentException
     * is thronw if the iterator supplied has not been generated by use of iteratorFind.
     *
     * @param itemIterator The iterator over the results (should be obtained from iteratorFind)
     * @exception IllegalArgumentException thrown if the Iterator is an invalid type
     */
    public void closeResults(Iterator itemIterator) {
        if (!(itemIterator instanceof OJBIterator)) {
            throw new IllegalArgumentException("parameter must be a valid Iterator generated from iteratorFind");
        }
        OJBIterator ojbIter = (OJBIterator) itemIterator;
        ojbIter.releaseDbResources();

    }

    /**
     * changes the username and password details used for connection.
     * Note that this is NOT currently a runtime change, but will change
     * to a different user if eg the DAO is serialized. This may be modified
     * later to (if possible) provide runtime user switching.
     *
     * @param user the new username
     * @param password the new user password
     */
    public void resetUserInfo(String user, String password) {
        this.user = user;
        this.password = password;
        PBKey defaultKey = MetadataManager.getInstance().getDefaultPBKey();
        connectionDetails = defaultKey.getAlias() + "#" + user + "#" + password;
    }

    public void addCachedClass(Class clazz) {
        cachedClasses.add(clazz);
    }

    public boolean isCachedClass(Class clazz) {
        return cachedClasses.contains(clazz);
    }

    public void clearCache() throws PersistenceBrokerException {
        broker.clearCache();
    }

    public void setLogger(Logger p) {
        logger = p;
    }

    /**
     * Provides the database name that is being connected to.
     * @return String the database name, or an empty String if the query fails
     */
    public String getDbName() {
        MetadataManager meta = MetadataManager.getInstance();
        PBKey pbkey = meta.getDefaultPBKey();
        JdbcConnectionDescriptor jDesc = meta.connectionRepository().getDescriptor(pbkey);
        if (jDesc.getDbAlias() != null) {
            return jDesc.getDbAlias();
        }
        return "";
    }

    /**
     * Provides the user name that is connecting to the DB.
     * @return String the user name, or an empty String if the query fails
     * @exception org.apache.ojb.broker.accesslayer.LookupException thrown on error
     * getting the Connection
     * @exception SQLException thrown if the metatdata can't be obtained
     */
    public String getDbUserName() throws LookupException, SQLException {
        String userName = "";
        Connection conn = broker.serviceConnectionManager().getConnection();
        DatabaseMetaData metaInfo = conn.getMetaData();
        userName = metaInfo.getUserName();
        return userName;
    }

    /**
     * Method to get a direct SQL connection which can be used by JDBC
     * @return java.sql.Connection to database
     * @throws LookupException
     */
    public Connection getJDBCConnection() throws LookupException {
        return broker.serviceConnectionManager().getConnection();
    }

    /**
     * Method to release a SQL connection which was obtained via
     * {@link #getJDBCConnection()} method.
     */
    public void releaseJDBCConnection() {
        broker.serviceConnectionManager().releaseConnection();
    }

    /**
     *   Used to begin a transaction. The transaction level (object or JDBC) should be
     * specified. Defaults to JDBC level.
     * @param txType The type of transaction to begin (JDBC or object)
     * @see uk.ac.ebi.intact.business.BusinessConstants
     *
     * @exception TransactionException - can be thrown if a transaction is already in progress
     *
     */
    public void begin(int txType) throws TransactionException {

        if (txType == BusinessConstants.OBJECT_TX) {
            try {
                //ODMG transaction...
                tx = odmg.newTransaction();
                tx.begin();
                transactionType = txType;  //flag it

                //broker.beginTransaction();
                logger.debug("STARTED the transaction");
            } catch (org.odmg.TransactionInProgressException pe) {
                //transaction already open - do something
                String msg = "failed begin: cannot begin a transaction as one is already open";
                throw new TransactionException(msg, pe);
            }
        } else {
            //JDBC transaction.
            broker.beginTransaction();
            transactionType = BusinessConstants.JDBC_TX;  //flag it
        }

    }

    /**
     * Locks the specified object to a transaction for WRITE. Note
     * that this method can ONLY be used if you are using object-level transactions
     * (it doesn't make sense for JDBC transactions)
     * @param obj The object to lock for write.
     * @exception org.odmg.TransactionNotInProgressException thrown if no object TX is running
     */
    public void lock(Object obj) throws org.odmg.TransactionNotInProgressException {
        if ((tx == null) || (!tx.isOpen()))
            throw new org.odmg.TransactionNotInProgressException();
        tx.lock(obj, Transaction.WRITE);
    }

    /**
     *   closes a DAO (connection).
     *
     * @exception DataSourceException - thrown if the DAO cannot be closed (details in specific errors)
     *
     */
    public void close() throws DataSourceException {
        //this releases the broker instance - assumes doing this also
        //releases the DB connection....(may need changing for OJB 0.9.7)
        //PersistenceBrokerFactory.releaseInstance(broker);
//        checkForOpenStore();
        if (!broker.isClosed()) {
            broker.close();
        }
        //clean up the ODMG stuff too
        try {
            db.close();
        }
        catch (ODMGException e) {
            throw new DataSourceException("failed to close datasource!", e);
        }
    }

    /**
     *   opens a DAO (connection). Note that connections are opened also via
     * the DAO constructor method, so this method should not be called unless
     * a previous call to close() has been made.
     *
     * @exception DataSourceException - thrown if the DAO cannot be closed (details in specific errors)
     *
     */
    public void open() throws DataSourceException {
        if (!broker.isClosed()) {
            // If it is active, just return.
            return;
        }
        odmg = OJB.getInstance();
        db = odmg.newDatabase();
        try {
            db.open(connectionDetails, Database.OPEN_READ_WRITE);
        }
        catch (ODMGException e) {
            e.printStackTrace();
            throw new DataSourceException("failed to open database!!", e);
        }
        broker = PersistenceBrokerFactory.createPersistenceBroker(
                new PBKey(repositoryFile, user, password));
    }

    /**
     *   Commits (finishes) a transaction. Usual meaning.
     *
     * @exception TransactionException - thrown if, say, a transaction was not in progress for example
     *
     */
    public void commit() throws TransactionException {

        try {

            //ODMG transaction...
            if (isODMGTransaction()) {
                try {
                    tx.commit();
                } catch (Exception ex) {
                    ex.printStackTrace();
                    //BUG: the following line is wrong since
                    //there is no guarantee the exception is
                    //a TransactionException; in fact it won't be!!
                    //this causes a ClassCastException when the
                    //ODMG tx.commit fails......
                    //throw (TransactionException) ex;
                    throw new TransactionException("ODMG transaction commit failed", ex);
                }

                //reset the TX reference to avoid confusion, and also
                //reset the transaction type flag ready for next time
                tx = null;
                transactionType = NULL_TX_TYPE;
            } else if (isJDBCTransaction()) {
                //it's a PB transaction instead
                broker.commitTransaction();
                //reset the transaction type flag ready for next time
                transactionType = NULL_TX_TYPE;
            } else {
                //error - trying to close a non-existent TX
                throw new TransactionException("error during commit - no transaction exists!");
            }
        } catch (org.odmg.TransactionAbortedException tae) {

            logger.error(tae.getCause());
            logger.error(tae.getMessage(), tae);

            //couldn't commit for some reason - do something
            String msg = "transaction commit failed";
            throw new TransactionException(msg, tae);
        } catch (org.odmg.TransactionNotInProgressException tne) {
            tne.getCause().printStackTrace();
            logger.error(tne.getCause());
            logger.error(tne.getMessage(), tne);

            //method called outside a transaction - do something
            String msg = "transaction commit failed";
            throw new TransactionException(msg, tne);
        }
    }

    /**
     * creates a single object in persistent store.
     *
     * @param obj - the object to be saved
     *
     * @exception CreateException
     *
     */
    public void create(Object obj) throws CreateException {
        //do this with ODMG....
//        checkForOpenStore();
        boolean localTx = false;
        try {

            if (isActive()) {
                logger.debug("Transaction already started");

                //create called as part of another TX, so lock it
                //note that the lock for write flag tells ODMG to write upon commit
                //NB ODMG associates the current thread with a TX, so we
                //should join the TX just in case the thread has changed since
                //the client begin() was called...
                if (isODMGTransaction()) {
                    logger.debug("Doing a object transaction");
                    //do the ODMG thing - otherwsie don't do anything!
                    tx.join();
                    tx.lock(obj, Transaction.WRITE);
                } else {
                    // JDBC Transaction.
                    broker.store(obj);
                }
            } else {
                logger.debug("Starting Local Transaction - default to JDBC type");
                //default to JDBC
                transactionType = BusinessConstants.JDBC_TX;
                localTx = true;
                broker.beginTransaction();
            }
            if (localTx) {

                //local transaction, so commit here instead...
                logger.debug("committing local TX");
                broker.store(obj);
                broker.commitTransaction();
            }
        } catch (Exception e) {

            if (localTx) {
                //local transaction failed - should rollback here..
                logger.error("aborting local TX");
                logger.error(e);
                broker.abortTransaction();
            }
            logger.debug("Exception from create", e);
            //Question: if the op fails, should the client TX abort too?...
            String msg = "create failed for object of type " + obj.getClass().getName();
            throw new CreateException(msg, e);
        }
    }

    public void removeFromCache(Object obj) {
        broker.removeFromCache(obj);
    }

    public void removeFromCache(Class realClass, String ac) {
        removeFromCache(new Identity(realClass, broker.getTopLevelClass(realClass),
                new Object[] {ac}));
    }

    public boolean isInCache(Class realClass, String ac) {
        Identity id = new Identity(realClass, broker.getTopLevelClass(realClass),
                new Object[] {ac});
        return broker.serviceObjectCache().lookup(id) != null;
    }

    public void forceUpdate(Object obj) throws UpdateException {
        update(obj, true);
    }

    /**
     * @see uk.ac.ebi.intact.persistence.DAO#update(Object)
     */
    public void update(Object obj) throws UpdateException {
        update(obj, false);
    }

    /**
     * Does the update here.
     * @param obj the object to update.
     * @param force true if update is to be forced.
     * @throws UpdateException
     */
    private void update(Object obj, boolean force) throws UpdateException {
        if (!isPersistent(obj)) {
            throw new UpdateException();
        }
        //use ODMG...
        //old PB code
        //ObjectModificationDefaultImpl mod = new ObjectModificationDefaultImpl();
        //mod.setNeedsUpdate(true);
        boolean localTx = false;
        Object dummy = null;

        logger.debug("doing update - searching for old data...");
        // Removed the object from cache for a database load to get the
        // true old data.

        broker.removeFromCache(obj);
        try {

            //NB To do a proper (intelligent) update:
            //1) get the "old" obj data from the DB
            //2) lock it for write in an ODMG transaction
            //3) copy the new data into it (harder than it sounds!!)
            //4) commit
            //
            Identity ident = new Identity(obj, broker);
            dummy = broker.getObjectByIdentity(ident);
            // dummy should never be null at this point.

            //check TX details and lock object into appropriate TX
            if (isActive()) {

                //NB ODMG associates the current thread with a TX, so we
                //should join the TX just in case the thread has changed since
                //the client begin() was called...
                logger.debug("client transaction detected - locking retrieved object for write..");
                if (isODMGTransaction()) {
                    tx.join();
                    tx.lock(dummy, Transaction.WRITE);
                }
            } else {
                //start a local TX - NB **** local TXs default to JDBC ****
                broker.beginTransaction();
                localTx = true;
            }

            //do some reflection/security stuff so we can set the fields to new values..

            //first though, need to get all the superclasses as we don't get them directly from a Class object...

            Collection superClasses = new ArrayList();
            Class tester = dummy.getClass();
            logger.debug("getting classes - first class is " + tester.getName());
            while (tester != Object.class) {
                logger.debug("superclass added to collection: " + tester.getName());
                superClasses.add(tester);

                //now get the next parent up
                tester = tester.getSuperclass();
            }

            logger.debug("parent classes obtained - getting all fields in hierarchy...");
            Collection fieldList = new ArrayList();
            Iterator it = superClasses.iterator();
            while (it.hasNext()) {
                Field[] superclassFields = ((Class) it.next()).getDeclaredFields();
                for (int i = 0; i < superclassFields.length; i++) {
                    logger.debug("field name: " + superclassFields[i].getName());
                    fieldList.add(superclassFields[i]);
                }
            }

            //convert list of fields to an array, as EccessibleObject needs
            //an array of AccessibleObjects as a param
            logger.debug("converting field list to array for security processing...");
            Field[] fields = (Field[]) fieldList.toArray(new Field[0]);

            try {
                //set the permissions on the fields - if this ever fails (eg if a
                //SecurityManager is set), need to
                //go via the AccessController...
                logger.debug("setting fields to be accessible for write...");
                AccessibleObject.setAccessible(fields, true);
            } catch (SecurityException se) {
                logger.error("failure during update - field access denied!!", se);
            }

            //now update them..
            Object value = null;
            logger.debug("The number of fields: " + fields.length);
            for (int i = 0; i < fields.length; i++) {

                try {
                    value = fields[i].get(obj);

                    // skip final field
                    if (Modifier.isFinal(fields[i].getModifiers()))
                        continue;

//                    logger.debug("field: " + fields[i].getName());
//                    logger.debug("old value: " + fields[i].get(dummy));
//                    logger.debug("new value: " + value);
                    fields[i].set(dummy, value);
                    logger.debug("field updated OK...");
                } catch (Exception e) {
                    logger.error("failed to update field " + fields[i].getName(), e);
                }
            }
            // Force the update if the flag is true. This is because OJB doesn't
            // mark the object as dirty if a collection's size is unchanged.
            if (force) {
                ((TransactionImpl) odmg.currentTransaction()).markDirty(dummy);
            }

            // No need to anything here for ODMG transactions as it is already
            // locked for write before the update.
            if (localTx) {
                //local transaction, so commit here instead...(JDBC)
                logger.debug("committing local TX");
                //tx1.commit();
                ObjectModificationDefaultImpl mod = new ObjectModificationDefaultImpl();
                mod.setNeedsUpdate(true);
                broker.store(obj, mod);
                broker.commitTransaction();
            } else if (isJDBCTransaction()) {
                // Not a local transaction; JDBC transaction.
                ObjectModificationDefaultImpl mod = new ObjectModificationDefaultImpl();
                mod.setNeedsUpdate(true);
                broker.store(obj, mod);
            }
        } catch (Exception e) {
            if (localTx) {
                //local transaction failed - should rollback here..
                logger.error("aborting local TX");
                logger.error(e);
                broker.abortTransaction();
            }
            //client should be responsible for aborting their own TX...
            //problem doing DB begin/commit, or updating object - do something
            String msg = "object update failed: problem updating object of type " + obj.getClass().getName();
            logger.debug("exception details: " + e.getMessage());
            logger.debug(e.toString());
            throw new UpdateException(msg, e);
        }
    }


    /**
     *   checks to see if a transaction is currently in progress. This will
     * test either an Object or JDBC level transaction, depending upon which
     * may be active (if any).
     *
     * @return boolean - true if a transaction is active, false otherwise
     */
    public boolean isActive() {
        if (isODMGTransaction()) {
            if (tx != null) {
                return tx.isOpen();
            }
        }
        if (isJDBCTransaction()) {
            return broker.isInTransaction();
        }
        return false;
    }

    /**
     *   checks to determine if a given object is persistent or not
     *
     * @param obj - the object to be checked
     *
     * @return boolean - true if the object is persistent (default), false for
     * all other instances.
     */
    public boolean isPersistent(Object obj) {
        // Check for the proxy first; if it is an Intact proxy, we assume it is a
        // persistent class.
        if (IntactObjectProxy.class.isAssignableFrom(obj.getClass())) {
            return true;
        }
        ClassDescriptor cldes = null;
        try {
            cldes = getClassDescriptor(obj.getClass());
        }
        catch (ClassNotPersistenceCapableException cnpce) {
            return false;
        }
        Object pkvalue = cldes.getPkFields()[0].getPersistentField().get(obj);
        if (pkvalue == null) {
            // Doesn't exist in the database
            return false;
        }
        // Got a non null primary key. However, the object in between create and
        // commit (e.g., object created and not comitted in a transaction).
        // Check for real by querying the database with an Identity.
        Identity ident = new Identity(obj, broker);
        Object dummy = broker.getObjectByIdentity(ident);
        if (dummy == null) {
            return false;
        }
        return true;
    }

    /**
     *   removes an object from persistent store.
     *
     * @param obj - the object to be removed
     *
     * @exception TransactionException - thrown usually if the operation is called outside a transaction
     *
     */
    public void remove(Object obj) throws TransactionException {
        //do this through ODMG - removes from the cache too...
        boolean localTx = false;
        try {

            //broker.delete(obj);
            if (!isActive()) {
                //start local transaction - don't need to lock for write as db.deletePersistent
                //does that for us
                //*** NB default to JDBC here ****
                broker.beginTransaction();
                logger.debug("local TX started to delete object " + obj.getClass().getName());
                localTx = true;
            }

            //NB if an Object TX, for multi-threaded calls, need to make sure that the current thread
            //is always connected to the client transaction as this is how ODMG works...
            if (isODMGTransaction()) {
                tx.join();
                db.deletePersistent(obj);
                logger.debug("object " + obj.getClass().getName() + " successfully locked for delete...");
            } else {
                //do a PB delete
                broker.delete(obj);
            }
            if (localTx) {
                //commit the local transaction
                logger.debug("commiting delete on local transaction for object " + obj.getClass().getName());
                broker.commitTransaction();
                logger.debug("local TX committed successfully");
            }
        } catch (Exception pbe) {

            if (localTx) {
                //should rollback the local TX
                logger.debug("error - local TX aborting...");
                logger.debug("failed due to " + pbe);
                broker.abortTransaction();
            }

            //should we rollback the client TX also??
            String msg = "remove for object type " + obj.getClass().getName() + " failed: see OBJ exception details";
            throw new TransactionException(msg, pbe);
        }
    }

    /**
     *  rollback a transaction. Usual meaning...
     *
     * @exception TransactionException - thrown if  the transaction couldn't be rolled back
     */
    public void rollback() throws TransactionException {
        try {
            if (isODMGTransaction()) {
                //make sure the current thread is associated with the TX first, to be safe
                tx.join();
                tx.abort();
            } else if (isJDBCTransaction()) {
                broker.abortTransaction();
            } else {
                //error - no TX exists...
                throw new TransactionException("error - cannto perform rollback: no transaction exists!");
            }
        } catch (org.odmg.TransactionNotInProgressException e) {
            String msg = "rollback failed: see OJB exception details";
            throw new TransactionException(msg, e);
        }
    }

    /**
     * This method performs a simple creation for a number of objects.
     *
     * @param objs - the collection of objects to be persisted
     *
     * @exception CreateException - thrown if an object could not be stored
     * @exception TransactionException - thrown if errors resulted from invalid transaction operations or errors
     *
     */
    public void makePersistent(Collection objs) throws CreateException, TransactionException {
        //local check flag for a localised transaction
        //do this in ODMG....
        boolean startedHere = false;

        if (objs != null) {

            Iterator it = objs.iterator();

            try {
                //check for a current transaction - if not, start one
                // **** NB all local TXs are JDBC ones *****
                if (!isActive()) {

                    begin(BusinessConstants.JDBC_TX);
                    startedHere = true;
                }
                while (it.hasNext()) {

                    create(it.next());
                }
                if (startedHere) {

                    commit();
                }
            } catch (TransactionException te) {

                rollback();
                throw te;

            } catch (CreateException ce) {

                rollback();
                throw ce;
            }
        } else {

            String msg = "creation error - no objects specified to be created!";
            throw new CreateException(msg);

        }

    }

    public Collection find(String type, String col, String val) throws SearchException {
        try {
            return find(Class.forName(type), col, val);

        } catch (ClassNotFoundException c) {
            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            logger.info(msg);
            throw new SearchException(msg, c);
        }
    }

    /**
     *   <p>This method searches the DB based on the information in the
     *   parameters. Note that this only supports a single parameter
     *   (simple) search at present - bulk searches are TBD </p>
     *
     * @param searchClass - the class to be searched
     * @param col - the parameter (column name) to search on (usually ac number or name)
     * @param val - the value of the search parameter. If null, then all items matching the class name will be returned
     *
     * @return a collection containing the results of the searches
     *
     * @exception SearchException -  thrown for errors during the search process, eg query problems
     * @exception NullPointerException thrown if the type is not specified
     *
     */
    public <T> Collection<T> find(Class<T> searchClass, String col, String val) throws SearchException {
        Collection results = new ArrayList();

        //debug info..
        long timer = 0;

        if (col == null) {
            //no table column
            String msg = "search failed: no search parameter specified in request";
            logger.info(msg);
            throw new SearchException(msg);
        }

        try {
            //should now call getConcreteClasses to obtain the concrete
            //Class instances we should build if necessary....
            Collection classesToSearch = getConcreteClasses(searchClass);

            Criteria crit = null;

            //check local cache first for the object, in case the col is not the PK
            if (isCachedClass(searchClass)) {

                logger.info("search class may be unique by criteria other than PK - trying local cache...");

                Object obj = cache.get(searchClass + "-" + col + "-" + val);

                if (obj != null) {

                    logger.debug("class " + obj.getClass().getName() + " found in local cache");
                    logger.debug("returning locally cached object as find result - class: " + obj.getClass().getName());
                    //as obj is unique, we are done
                    results.add(obj);
                    return results;

                }
            }
            //build a normal Criteria query, if class is cached locally or not (
            //if found locally, would have returned by here)
            if (val != null) {
                crit = new Criteria();
                //crit.addEqualTo(col, val);
                addSearchClause(crit, col, val);
            }

            logger.info("criteria built OK");
            //now build a query for each search class...
            Collection queries = new ArrayList(classesToSearch.size());
            Class clazz = null;
            String concreteType = null;
            Criteria typeCriteria = null;
            Criteria queryCriteria = null;
            for (Iterator it = classesToSearch.iterator(); it.hasNext();) {
                //query = new QueryByCriteria(searchClass, crit);
                 clazz = (Class)it.next();
                //each type to search may be different - get the info and use it
                concreteType = clazz.getName();
                //System.out.println("concrete type to be searched: " + concreteType);
                queryCriteria = new Criteria(); //holds all the search criteria
                //if (val != null) queryCriteria.addEqualTo(col, val);
                if (val != null) addSearchClause(queryCriteria, col, val);
                //check to see if the table holds multiple object types,
                //and add an extra criteria if so
                if( isTypeNeeded( concreteType ) ) {
                    typeCriteria = new Criteria();
                    //add the type info, then add the value info if it was given
                    typeCriteria.addEqualTo(ClassDescriptor.OJB_CONCRETE_CLASS, concreteType);
                    // this works!! if (val != null) typeCriteria.addEqualTo(col, val);

                    //BUT for 'older' data the classname in the DB may not
                    //have the 'Impl' at the end, so we need to check for those
                    //too....

                    // TODO: NullPointerException can occur here !
                    // TODO: If a concrete class don't have Impl as suffix, it fails.
                    int index = concreteType.indexOf("Impl");
                    if( index != -1 ) {
                        String oldType = concreteType.substring( 0, index );
                        //System.out.println("old type name: " + oldType);
                        Criteria oldTypeCriteria = new Criteria();
                        oldTypeCriteria.addEqualTo(ClassDescriptor.OJB_CONCRETE_CLASS, oldType);
                        typeCriteria.addOrCriteria(oldTypeCriteria);
                    }



                    //now add the type info to the query criteria
                    queryCriteria.addAndCriteria(typeCriteria);
                    //System.out.println("Query built for " + concreteType + ":");
                    //Query dummy = new QueryByCriteria(clazz, typeCriteria);
                    Query dummy = new QueryByCriteria(clazz, queryCriteria);
                    //printQuery(dummy);  //debug
                    queries.add(dummy);
                }
                else {
                    //normal query
                    queries.add(new QueryByCriteria(clazz, crit));
                }
            }
            logger.info("query by criteria built OK: " + col + " " + val);

            //simple timing
            //System.gc();
            long tmp = System.currentTimeMillis();
            //System.gc();
            timer = System.currentTimeMillis();

            for (Iterator queryIt = queries.iterator(); queryIt.hasNext();) {
                results.addAll(broker.getCollectionByQuery((Query) queryIt.next()));
            }

            tmp = System.currentTimeMillis();
            timer = tmp - timer;
            logger.info("******************************************");
            logger.info("time in OJB query execute (ms): " + timer);
            logger.info("******************************************");

        } catch (PersistenceBrokerException pbe) {
            pbe.printStackTrace();
            //problem doing the query....
            String msg = "search failed: problem executing query";
            logger.info(msg);
            //NB with the Collection of queries the debug below needs modifying...
//            logger.info("Criteria: " + query.getCriteria().toString() + "\n");
//            logger.info("class: " + query.getSearchClass().getName() + "\n");
//            logger.info("attribute requested: " + query.getRequestedAttribute() + "\n");
            throw new SearchException(msg, pbe);
        }

        //Possible that only PROXIES have been returned - if so then we
        //should really return the concrete classes instead (we only need proxies
        //inside an object's own collections - currently (!)...
        Collection finalResults = checkProxies(results);

        if ((isCachedClass(searchClass)) & (!results.isEmpty())) {

            //must have a unique result that could be queried other than by PK, so cache it locally
            Iterator it = finalResults.iterator();
            Object obj = it.next();
            if (it.hasNext()) {

                //some problem - expecting a unique result...
                throw new SearchException("search error - expecting a unique result but got more than one");
            }
            cache.put(searchClass + "-" + col + "-" + val, obj);
        }

        return finalResults;
    }

    /**
     *   @see uk.ac.ebi.intact.persistence.DAO
     * Note: the local cache of non-PK fields is not currently used in this method (to do)
     */
    public Collection find(Object obj) throws SearchException {

        //IMPORTANT!! OJB queryByExample only works on IDs again, ie it is not a "real"
        //search by object. If the example has no ID set it returns all for that class.
        //see private method buildQueryByExample for an attempt to do it properly.....

        Query query = null;
        Collection results = new ArrayList();

        //debug info..
        long timer = 0;

        //first check the param
        if (obj == null) {

            //no search value
            String msg = "search failed: no search value specified in request";
            logger.info(msg);
            throw new SearchException(msg);
        }

        try {

            query = buildQueryByExample(obj);
            logger.info("query by example built OK");

            timer = System.currentTimeMillis();

            //get a Collection - may be more than one object matching the example
            results = broker.getCollectionByQuery(query);

            long tmp = System.currentTimeMillis();
            timer = tmp - timer;
            logger.info("******************************************");
            logger.info("search by object: time in OJB query execute (ms): " + timer);
            logger.info("******************************************");

        } catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem executing query " + query.toString();
            logger.info(msg);
            throw new SearchException(msg, pbe);

        }

        return results;
    }

// ------------------------- some convenience search methods --------------------------
    /**
     * This method provides a means of obtaining particular values of a persistent
     * object without retrieving the whole object itself. It therefore allows users
     * to obtain table column values.
     * @param type the object type you want details of (must be specified)
     * @param cols the table columns (NOT attribute names) you are interested in (null
     * will retrieve all of them)
     * @return Iterator an iterator over the requested table column values - NB
     * each item in the Iterator is of type Object, and must therefore be cast
     * to the correct type by the user of this method. If you do not exhaust the
     * iterator then to clean up DB resources you must pass the Iterator to the
     * <code>closeResults</code> method of this class. Null is returned if no results found
     *
     * @exception SearchException trhown if a problem occurs whilst searching the data store
     * @exception NullPointerException thrown if the type is null
     */
    public Iterator findColumnValues(String type, String[] cols) throws SearchException {

        if (type == null)
            throw new NullPointerException("can't query with a null type!!");
        ReportQueryByCriteria query = null;
        try {

            //empty Criteria OK, as this should result in a simple select on the cols
            query = new ReportQueryByCriteria(Class.forName(type), cols, new Criteria());
            Iterator results = broker.getReportQueryIteratorByQuery(query);
            return results;
        } catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem finding column details";
            logger.info(msg);
            if (query != null) {
                logger.info("class: " + query.getSearchClass().getName() + "\n");
                logger.info("attribute requested: "
                        + query.getObjectProjectionAttribute() + "\n");
            }
            throw new SearchException(msg, pbe);

        } catch (ClassNotFoundException c) {

            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            logger.info(msg);
            throw new SearchException(msg, c);


        }
    }

    /**
     * This method allows submission of a query by straight SQL string. If the string
     * is garbage then expect garbage back - no guarantees are made for the results.
     * @param type the object type you want details of (must be specified)
     * @param sqlString the string to be used for the query
     * @return A Collection of search results, or empty if none found
     * @exception SearchException thrown if a problem occurs whilst searching the data store
     * @exception NullPointerException thrown if the type is null
     */
    public Collection findBySQL(String type, String sqlString) throws SearchException {

        if (type == null)
            throw new NullPointerException("can't query with a null type!!");
        Collection results = new ArrayList();
        QueryBySQL query = null;
        try {

            query = new QueryBySQL(Class.forName(type), sqlString);
            results = broker.getCollectionByQuery(query);
            return results;
        } catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem doing raw SQL string search";
            logger.info(msg);
            if (query != null) {
                logger.info("SQL submitted: " + query.getSql()+ "\n");
            }
            throw new SearchException(msg, pbe);

        } catch (ClassNotFoundException c) {

            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            logger.info(msg);
            throw new SearchException(msg, c);
        }
    }

    /**
     *   <p>This method provides a means to obtain an Iterator for search results. This
     * can be useful if you need direct control over a result set, because OJB iterators have access to
     * result sets which may then be closed by passing the iterator back to the
     * <code>closeResults</code> method. Note that this approach will not tidy up
     * open cursors on an oracle server - the only way to do this seems to be
     * to close the connection, which is done automatically via the <code>find</code>
     * method (this is OK if oracle connection pooling is used).</p>
     *
     * @param type - the class name (ie table) to be searched
     * @param col - the parameter (column name) to search on (usually ac number or name)
     * @param val - the value of the search parameter
     *
     * @return an Iterator over the results set - null if no results found
     * @exception NullPointerException thrown if the type is null
     * @exception SearchException -  thrown for errors during the search process, eg query problems
     */
    public Iterator iteratorFind(String type, String col, String val) throws SearchException {
        Query query = null;
        Iterator resultIterator = null;
        Class searchClass = null;

        //holds anything obtained from a locally cached class
        Collection results = new ArrayList();

        //first check the params
        if (type == null)
            throw new NullPointerException("can't search with an empty type!");
        if (col == null) {

            //no table column
            String msg = "search failed: no search parameter specified in request";
            logger.info(msg);
            throw new SearchException(msg);
        }

        try {

            searchClass = Class.forName(type);
            Criteria crit = null;

            //check local cache first for the object, in case the col is not the PK
            if (isCachedClass(searchClass)) {

                logger.info("search class may be unique by criteria other than PK - trying local cache...");

                Object obj = cache.get(searchClass + "-" + col + "-" + val);

                if (obj != null) {

                    logger.debug("class " + obj.getClass().getName() + " found in local cache");
                    logger.debug("returning locally cached object as find result - class: " + obj.getClass().getName());
                    //as obj is unique, we are done
                    results.add(obj);
                    return results.iterator();

                }
            }

            if (val != null) {
                //fully specified search value
                crit = new Criteria();
                crit.addEqualTo(col, val);
            }
            //}
            logger.info("criteria built OK");
            query = new QueryByCriteria(searchClass, crit);
            logger.info("query by criteria built OK: " + type + " " + col + " " + val);

            //do it - NB can't do the PB TX thing for oracle here, as the
            //iterator is 'aware' of TXs and so committing will screw up
            //the iterator. The user has to handle it!
            resultIterator = broker.getIteratorByQuery(query);

        } catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem executing query";
            logger.info(msg);
            logger.info("Criteria: " + query.getCriteria().toString() + "\n");
            logger.info("class: " + query.getSearchClass().getName() + "\n");
            throw new SearchException(msg, pbe);

        } catch (ClassNotFoundException c) {

            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            logger.info(msg);
            throw new SearchException(msg, c);


        }

        if ((isCachedClass(searchClass)) & (!results.isEmpty())) {

            //must have a unique result that could be queried other than by PK, so cache it locally
            Iterator it = results.iterator();
            Object obj = it.next();
            if (it.hasNext()) {

                //some problem - expecting a unique result...
                throw new SearchException("search error - expecting a unique result but got more than one");
            }
            cache.put(searchClass + "-" + col + "-" + val, obj);
        }

        return resultIterator;
    }

    public String getTableName(Class clazz) {
        ClassDescriptor cld = broker.getDescriptorRepository().getDescriptorFor(clazz);
        if (cld == null) {
            return null;
        }
        return cld.getFullTableName();
    }

    /**
     * Returns the number of items retrieved by executing the query.
     * @param query the query to execute.
     * @return the number of items retrieved by executing <code>query</code>.
     */
    public int getCountByQuery(Query query) {
        return broker.getCount(query);
    }

    /**
     * Returns the Object for the given query.
     * @param query the query to execute.
     * @return the object retrieved by executing <code>query</code>.
     */
    public Object getObjectByQuery(Query query) {
        return broker.getObjectByQuery(query);
    }

    /**
     * Returns a collection of items retrieved by executing the query.
     * @param query the query to execute.
     * @return a collection items retrieved by executing <code>query</code>.
     */
    public Collection getCollectionByQuery(Query query) {
        return broker.getCollectionByQuery(query);
    }

    /**
     * Returns an iterator for executing the query.
     * @param query to execute.
     * @return an iterator consists of Object[].
     */
    public Iterator getIteratorByReportQuery(Query query) {
        return broker.getReportQueryIteratorByQuery(query);
    }

    /**
     * Returns the underlying broker.
     * @return the persistence broker
     */
    public PersistenceBroker getBroker() {
        return this.broker;
    }

//-------------------------- private helper methods ----------------------------------------

    /**
     * <p>
     *  This method builds an OJB query based on the contents of the object parameter.
     * Specifically a query is built from any non-null field, object reference or
     * collection of the object parameter.</p>
     * <p>
     * NOTE: A query will be built from an example object as follows:
     * - only ONE example item from any of the groups fields, references or collections, is
     * needed to build a query. In some cases (eg where an m:n relation is supplied in the
     * example object) then q special query will be built, overriding any previous search criteria.
     * This is because a different query is needed in those cases, and the search result will be the same.
     * </p>
     * <p>
     * LIMITATIONS:
     *
     * a) reference objects set within the example must have their primary key
     *    attribute set
     * b) for example objects with Collections, a collection must have at least one element
     *    and the element must have at least its Primary Key set
     * </p>
     *
     * @param obj The example object to search on
     *
     * @return Query A suitable search query object
     */
    private Query buildQueryByExample(Object obj) {

        Query query = null;
        Criteria criteria = new Criteria();

        //get some info on the parameter object's OJB details....
        ClassDescriptor cld = MetadataManager.getInstance().getRepository().getDescriptorFor(obj.getClass());
        FieldDescriptor[] fds = cld.getFieldDescriptions();
        String objClassName = obj.getClass().getName();

        logger.debug("DAO: field descriptions for object " + objClassName + " :");

        //worker variables to hold persistent fields and their values set in the example obj
        PersistentField field;
        Object value;

        //handle "simple" fields eg String, Date etc
        logger.debug("field info for object " + objClassName + ":");
        for (int i = 0; i < fds.length; i++) {
            try {

                field = fds[i].getPersistentField();
                value = field.get(obj);

                logger.debug("name: " + field.getName());
                logger.debug("type: " + field.getType());

                if (value != null) {
                    //OK to use the field name - its mapping to a column name is handled by OJB...
                    criteria.addEqualTo(field.getName(), value);
                    logger.debug("value: " + value.toString());
                }
            } catch (Throwable ex) {

                logger.error(ex);
            }
        }

        //try object refs..
        Vector objRefs = cld.getObjectReferenceDescriptors();
        Iterator it1 = objRefs.iterator();
        logger.debug("reference object details for " + objClassName + ":");

        while (it1.hasNext()) {
            ObjectReferenceDescriptor refDesc = (ObjectReferenceDescriptor) it1.next();

            logger.debug("name: " + refDesc.getAttributeName());
            logger.debug("type: " + refDesc.getClass().getName());

            buildObjectRefCriteria(refDesc, criteria, obj);

        }

        //try Collection fields...
        Vector collectionDescs = cld.getCollectionDescriptors();
        Iterator it = collectionDescs.iterator();
        logger.debug("collection descriptor details for " + objClassName + ":");
        while (it.hasNext()) {

            //go through the collections until we find a single one
            //containing data - only one is needed to obtain the target PK we want
            CollectionDescriptor collectionDesc = (CollectionDescriptor) it.next();

            logger.debug("name: " + collectionDesc.getAttributeName());
            logger.debug("item type:" + collectionDesc.getItemClass().getName());
            logger.debug("persistent field: " + collectionDesc.getPersistentField().getName());

            try {
                field = collectionDesc.getPersistentField();
                Collection col = (Collection) field.get(obj);

                //got a Collection - now  need to add its details to the search info..
                if ((col != null) & (!col.isEmpty())) {

                    if (collectionDesc.isMtoNRelation()) {

                        //need to get a query as there is a specific one for m:n mappings#
                        //NB can ignore any criteria supplied so far
                        query = buildMtoNQuery(cld, collectionDesc, obj);

                        //only need ONE collection example....
                        break;
                    } else {

                        buildCollectionCriteria(cld, collectionDesc, criteria, obj);

                        //only need to find one entry as we can get the target PK from it
                        query = new QueryByCriteria(obj.getClass(), criteria);
                        break;
                    }
                }
            } catch (Throwable ex) {

                logger.error(ex);
            }
        }

        if (query == null) {

            //didn't get any info from collection - so buld a query on what we have
            query = new QueryByCriteria(obj.getClass(), criteria);

        }
        return query;

    }

    /**
     * private method to handle query building based on an example object that contains
     * a non-null collection. Note that for this to be possible the collection must contain
     * at least one object which has (at least) its primary key set.
     *
     * This method handles collections which model 1:n relations only - for m:n relations
     * the method buildMtoNQuery should be used.
     *
     * @param targetDesc The Class Descriptor of the target object
     * @param collectionDesc The CollectionDescriptor for the example object
     * @param obj The example search object
     *
     * @exception PersistenceBrokerException Thrown if there were OJB problems
     *
     */
    private void buildCollectionCriteria(ClassDescriptor targetDesc,
                                         CollectionDescriptor collectionDesc,
                                         Criteria criteria, Object obj)
            throws PersistenceBrokerException {

        //get some basic info first
        PersistentField field = collectionDesc.getPersistentField();
        Collection collection = (Collection) field.get(obj);
        Vector inverseFkIds = collectionDesc.getForeignKeyFields();

        logger.debug("search by object (collection): field in example object " + obj.getClass().getName() + " with collection is " + field.getName());


        if (inverseFkIds != null) {

            //must be: a) elements with inverse FKs (ie 1:n mappings)....
            /*
            * sketch:
            *
            * - get the FK pointing to the target obj from any non-null Collection element
            *   (if it is not set via the example obj, go to the DB for it via the element PK)
            * - build in an addEqualTo criteria for the target obj's PK
            */

            //must only be one, as we know by now the relation to the Collection is 1:n
            int inverseFkId = ((Integer) inverseFkIds.firstElement()).intValue();
            logger.debug("ID of inverse foreign key is " + inverseFkId);

            //get the PK value from the FK in the example if set, or from the DB if not...
            if (collection != null) {

                Iterator it = collection.iterator();

                //only need one example element...
                if (it.hasNext()) {

                    Object element = it.next();
                    // Element must be persistable.
                    if (!isPersistent(element)) {
                        throw new PersistenceBrokerException("Found an element that isn't persistent");
                    }

                    // To get this far; element is already persistent.

                    logger.debug("class of collection elements is " + element.getClass().getName());

                    //get basic info on the element and its relevant FK
                    ClassDescriptor elemDesc = MetadataManager.getInstance().getRepository().getDescriptorFor(element.getClass());
                    FieldDescriptor elemFieldDesc = elemDesc.getFieldDescriptorByIndex(inverseFkId);
                    PersistentField persistentField = elemFieldDesc.getPersistentField();

                    Object val = persistentField.get(element);

                    if (val == null) {

                        logger.debug("search by object (collection sub-field): no inverse key set in element....");
                        logger.debug("querying DB to get the inverse key to target...");

                        //assumes collection element in example has PK set
                        Object dbElement = broker.getObjectByIdentity(new Identity(element, broker));
                        if (dbElement != null) {

                            logger.debug("DB element obtained OK - collection element details:");
                            logger.debug(dbElement.toString());

                            //now get the FK value...
                            val = persistentField.get(dbElement);
                        } else {
                            // We shouldn't get here because we have already chekced for persistence
                            // above.
                            logger.debug("error - no collection element found in DB either.");
                            logger.debug("unable to build FK relationship between collection elements and target object!!");
                            throw new PersistenceBrokerException("search by object: failed to find example details in DB");
                        }
                    }

                    //now add in the criteria details...
                    FieldDescriptor[] fieldDescs = targetDesc.getPkFields();
                    if ((fieldDescs == null) || (fieldDescs.length > 1)) {

                        //a problem - should only have one PK field!!
                        logger.debug("search by object (collection): target object has zero or > 1 primary key fields!!");
                        throw new PersistenceBrokerException("search by object: descriptor for class " + targetDesc.getClassOfObject().getName() + " has zero or > 1 primary keys!!");

                    }
                    String pkField = fieldDescs[0].getAttributeName();
                    criteria.addEqualTo(pkField, val);

                    logger.debug("search by object (collection): searching for object of type " + targetDesc.getClassOfObject().getName() + "with details:");
                    logger.debug("PK field: " + pkField);
                    logger.debug("value: " + val.toString());

                }
            }

        } else {

            //something wrong - Collection descriptor is not 1:n or m:n, so unknown!!
            throw new PersistenceBrokerException("object search (collection): collection is not 1:n or m:n relation, and so invalid!!");
        }

    }


    /**
     * Builds a specific query for use with m:n mappings. This case must be handled differently
     * to a 1:n collection mapping as indirection tables are involved.
     *
     * @param targetDesc The Class Descriptor of the target object of the search
     * @param collectionDesc The Collection Descriptor of the m:n mapping
     * @param obj The example object to base a search on
     *
     * @return Query A complete query containing all previous criteria plus m:n (indirection table) details
     *
     * @exception PersistenceBrokerException Thrown if there are OJB problems
     *
     */
    private Query buildMtoNQuery(ClassDescriptor targetDesc, CollectionDescriptor collectionDesc, Object obj) throws PersistenceBrokerException {

        //b) indierection table case (ie m:n mappings).....
        logger.debug("search by object (collection): need to check indirection table...");

        Query query = null;

        //get some basic info
        PersistentField field = collectionDesc.getPersistentField();
        Collection collection = (Collection) field.get(obj);

        /*
        * sketch:
        *
        * Need to build a special m:n query with the following info:
        * - the name of the indirection table;
        * - the PK column name of the target object;
        * - the column name of the indirection table that matches the target object PK column;
        * - the PK of a single element in the collection example;
        * - the column of the indirection table matching the element PK
        *
        */

        //NB these return the column names from the indirection table as String objects
        //(undocumented in the OJB javadoc - Object[] is not very helpful!!)
        Object[] elemClassFks = collectionDesc.getFksToItemClass();
        Object[] targetClassFks = collectionDesc.getFksToThisClass();

        String indirectionTable = collectionDesc.getIndirectionTable();

        logger.debug("indirection table: " + indirectionTable);
        logger.debug("column name holding element PK: " + elemClassFks[0]);
        logger.debug("column name holding target PK: " + targetClassFks[0]);

        if (collection != null) {

            Iterator it = collection.iterator();

            if (it.hasNext()) {

                //only need one example element as they would all relate to the same target PK..
                Object elem = it.next();
                ClassDescriptor elemDesc = MetadataManager.getInstance().getRepository().getDescriptorFor(elem.getClass());
                FieldDescriptor[] elemFieldDesc = elemDesc.getPkFields();

                //assume only one PK for the collection element (not unreasonable!!...)
                PersistentField pkField = elemFieldDesc[0].getPersistentField();
                Object elemPk = pkField.get(elem);

                //now build criteria to match up the element PK, indirection table and target..
                //NB ASSUMES that only one FK to an element class is defined in the Collection Descriptor
                //(which must be true - I think!)
                Criteria criteria = new Criteria();
                criteria.addEqualToColumn(indirectionTable + "." + targetClassFks[0], targetDesc.getPkFields()[0].getAttributeName());

                if (elemPk != null) {

                    logger.debug("PK field for element class " + elemDesc.getClassOfObject().getName() + " : " + elemPk);
                    criteria.addEqualTo(indirectionTable + "." + (String) elemClassFks[0], elemPk);
                } else {

                    //must have at least the PK of the example element set, otherwise can't search...
                    throw new PersistenceBrokerException("search by object (m:n collection): collection element must have at least its Primary Key set to perofrm a search");
                }

                //now build the m:n query
                query = new QueryByMtoNCriteria(targetDesc.getClassOfObject(), indirectionTable, criteria);

            } else {

                //error - can't work with an empty collection...
                throw new PersistenceBrokerException("search by object (m:n collection): empty collection in search example!!");
            }

        }

        return query;

    }

    /**
     * For a search example containing an object reference, builds the appropriate
     * search criteria. Note: it is assumed that a contained object reference
     * has at least its Primary Key defined.
     *
     * @param refDesc The descriptor for the object reference
     * @param criteria The Criteria object that the result is to be added to
     * @param obj The example search object
     *
     */
    private void buildObjectRefCriteria(ObjectReferenceDescriptor refDesc, Criteria criteria, Object obj) {

        /*
        * Sketch:
        * for each object reference of the target object that has a value set in the example,
        * - get the PK of the reference;
        * - find its corresponding FK field in the target object;
        * - build a query with a Criteria containing addEqualTo for the FK/PK pair
        *
        *
       */

        try {

            //get the value of the reference field from the example object supplied
            PersistentField field = refDesc.getPersistentField();
            Object value = field.get(obj);

            if (value != null) {

                // subqueries not supported by OJB, so can't use them -
                //need then to work with the ClassDescriptor of the reference supplied
                //in the example obj....

                ClassDescriptor valueCd = MetadataManager.getInstance().getRepository().getDescriptorFor(value.getClass());
                Object key = valueCd.getPrimaryKey().getPersistentField().get(value);

                //also need the FK in the target that this PK is held in..
                //the ID of the FK field can be obtained from the ObjectReferenceDescriptor
                //as a Vector of Integer - but this is likely only ever to contain one ID!!
                Vector fkIds = refDesc.getForeignKeyFields();
                if ((fkIds.size() > 1) || (fkIds.size() == 0)) {

                    //something odd - reference has zero or more than one FK attribute in the target!!
                    logger.error("object-based search: zero or more than one FK attribute present for an object reference!!");
                } else {

                    int fkId = ((Integer) fkIds.firstElement()).intValue();

                    //now find the field in the target with this ID and compare to the PK
                    ClassDescriptor cld = MetadataManager.getInstance().getRepository().getDescriptorFor(obj.getClass());
                    FieldDescriptor fkFieldDesc = cld.getFieldDescriptorByIndex(fkId);
                    PersistentField fkField = fkFieldDesc.getPersistentField();
                    criteria.addEqualTo(fkField.getName(), key);

                }

            }
        } catch (Throwable ex) {

            logger.error(ex);
        }

    }

    /**
     * For the given class, checks whether or not it is abstract (ie it has
     * extents in OJB) and if so obtains all the CONCRETE classes that are
     * relevant to it. This enables OJB queries to be made with concrete class
     * details rather than possibly abstract ones, and so avoids any possible
     * problems with the way OJB handles abstract class queries.
     * @param classToCheck The class to investigate
     * @return Collection a Collection of concrete classes - empty if nothing found
     */
    private Collection getConcreteClasses(Class classToCheck) {

        Collection result = new ArrayList();
        ClassDescriptor classDesc = getClassDescriptor(classToCheck);
        if (classDesc != null) {

            //NB if this doesn't work we could just check to see if it is abstract..
            if (!classDesc.isExtent()) {
                //concrete already - just return it
                result.add(classToCheck);
            } else {
                //get all of the concrete classes we can find
                Vector subClasses = classDesc.getExtentClasses();
                for (Iterator it = subClasses.iterator(); it.hasNext();) {
                    Class subClass = (Class) it.next();
                    // ClassDescriptor subClassDesc = getClassDescriptor(subClass);
                    result.addAll(getConcreteClasses(subClass));
                }

            }
        }

        return result;
    }

    /**
     * trivial method to obtain an OJB class descriptor for a given class.
     * @param clazz The class we are interested in
     * @return ClassDescriptor The OJB class descriptor for that class (as specified
     * in the repositro_user.xml configuration) - null if the descriptor does not exist
     */
    private ClassDescriptor getClassDescriptor(Class clazz) {
        return (MetadataManager.getInstance().getRepository().getDescriptorFor(clazz));
    }

    /**
     * True if the current transaction type is of ODMG type.
     * @return true if the current transaction type is of object type.
     */
    private boolean isODMGTransaction() {
        return transactionType == BusinessConstants.OBJECT_TX;
    }

    /**
     * True if the current transaction type is of JDBC type.
     * @return true if the current transaction type is of JDBC type.
     */
    private boolean isJDBCTransaction() {
        return transactionType == BusinessConstants.JDBC_TX;
    }

    /**
     * Used as part of the query building process to ensure that only queries are built
     * for matching types. For '*' searches, OJB loads all rows and otherwise ignores
     * types (particularly for proxy generation) - this is incorrect behaviour for tables
     * that have more than one object mapped to them. Doing this check refines the query
     * and thus also stops OJB from loading all rows of a multi-mapped table.
     * @return true if the class to be searched is in a multi-mapped table, false otherwise.
     */
    private boolean isTypeNeeded(String classToFind) {

        ClassDescriptor cld = broker.getDescriptorRepository().getDescriptorFor(classToFind);
        if(cld == null) return false;

        // check if there is an attribute which tells us which concrete class is to be instantiated
        FieldDescriptor concreteClassFD = cld.getFieldDescriptorByName(ClassDescriptor.OJB_CONCRETE_CLASS);

        //case where the class to search is a single object to table map -
        //in this case the descriptor will have no OJB concrete class field declared
        if (concreteClassFD == null)
            return false;
        return true;

    }

    private void printQuery(Query query) {

        System.out.println("Query details:");
        System.out.println("Class: " + query.getSearchClass().getName());
        System.out.println("Query Criteria: ");
        printCriteria(query.getCriteria());
        System.out.println();

    }

    private void printCriteria(Criteria crit) {
        System.out.println("Criteria:");
        for(Enumeration e = crit.getElements(); e.hasMoreElements();) {
            Object elem = e.nextElement();
            if(elem instanceof Criteria) {
                //sub-criteria - print them..
                System.out.println("nested criteria:");
                printCriteria((Criteria)elem);
            }
            else {
                System.out.println(elem);
            }
        }
    }

    /**
     * Helper method to analyse a Collection and get the real items from
     * the contents if they are Proxies.
     * @param items The objects to check
     * @return Collection a list of full objects, or empty if no proxies found
     */
    private Collection checkProxies(Collection items) {

        Collection results = new ArrayList();
        Object obj = null;
        for(Iterator it = items.iterator(); it.hasNext();) {
            obj = it.next();
            if(VirtualProxy.class.isAssignableFrom(obj.getClass())) {
                //need to get the real object and return that instead
                results.add(((VirtualProxy)obj).getRealSubject());
            }
            else {
                //not a proxy - return it anyway
                results.add(obj);
            }
        }
        return results;

    }

    /**
     * Convenience method to add an appropriate clause to a search Criteria object.
     * Thus an equality clause is added in general, but if any wildcard characters
     * (as specified by '*' or '%') exist in the search value then a 'like' clause
     * is added instead.
     * @param crit The Criteria object to which the clause should be added
     * @param column The column to seacrh on
     * @param value The value to search with - may contain '*' or '%'.
     */
    private void addSearchClause(Criteria crit, String column, String value) {
        if((value.indexOf('*') != -1) || (value.indexOf('%') != -1)) {
            //some wildcards in the string - add a 'like' clause
            crit.addLike("upper("+column+")", value.toUpperCase());
        }
        else {
            //normal equality..
            crit.addEqualTo("upper("+column+")", value.toUpperCase());
        }
    }
}
