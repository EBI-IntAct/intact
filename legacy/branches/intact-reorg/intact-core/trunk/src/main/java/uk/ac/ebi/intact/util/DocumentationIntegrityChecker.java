/*
Copyright (c) 2002 The European Bioinformatics Institute, and others.  
All rights reserved. Please see the file LICENSE 
in the root directory of this distribution.
*/
package uk.ac.ebi.intact.util;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import java.util.HashMap;
import java.util.Set;
import java.util.Iterator;
import java.io.File;
import java.io.IOException;

/**
 * Allows to check if the IntAct documentation is ready to be generated by checking if
 * a section is used several times.
 *
 * @author Samuel Kerrien (skerrien@ebi.ac.uk)
 * @version $Id$
 */
public class DocumentationIntegrityChecker {

    static Document document;
    private HashMap<String,Integer> sections = null; // hold section name count

    /**
     * Update the section names list by traversing the DOM tree.
     * This is done recursivly.
     *
     * @param node the root node
     */
    private void traverse (Node node) {

        sections = new HashMap<String,Integer>();
        int type = node.getNodeType();

        // check if element
        if (type == Node.ELEMENT_NODE) {
            if ("section".equals (node.getNodeName())) {
                NamedNodeMap AttributesList = node.getAttributes();
                // iterate through the attribute names and values
                for (int j = 0; j < AttributesList.getLength(); j++) {
                    String attributeName = AttributesList.item(j).getNodeName();
                    if ("name".equals(attributeName)) {
                        String name = AttributesList.item(j).getNodeValue();

                        Integer count = sections.get (name);
                        if (count != null) {
                            // was already in ...
                            count = count + 1;
                        } else {
                            count = new Integer ("1");
                        }

                        sections.put(name, count);
                        System.out.println (AttributesList.item(j).getNodeValue());
                    }
                }
            }
        }

        // check if current node has any children
        NodeList children = node.getChildNodes();
        if (children != null) {
            // if it does, iterate through the collection
            for (int i=0; i< children.getLength(); i++) {
                // recursively call function to proceed to next level
                traverse (children.item(i));
            }
        }
    }


    /**
     * Check the section's name list and sends back 0 is everything's ok, else 1.
     *
     * @return 0 is everything's ok, else 1
     */
    private int report () {

        if (sections == null) return 0;

        boolean ok = true;
        Set<String> sectionNames = sections.keySet();

        for (String name : sectionNames)
        {
            int count = sections.get(name);
            if (count > 1)
            {
                System.out.println(name + " is used " + count + " times.");
                ok = false;
            }
        }

        if (ok) return 0;
        else return 1;
    }

    public static void main(String argv[]) {

        if (argv.length != 1) {
            System.err.println("Usage: java DocumentationIntegrityChecker filename");
            System.exit(1);
        }

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

        try {
            DocumentBuilder builder = factory.newDocumentBuilder();
            document = builder.parse ( new File(argv[0]) );

            DocumentationIntegrityChecker checker = new DocumentationIntegrityChecker ();
            checker.traverse (document);
            System.exit (checker.report());

        } catch (SAXException sxe) {
            // Error generated during parsing)
            Exception  x = sxe;
            if (sxe.getException() != null)
                x = sxe.getException();
            x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }

        // we get here in case an exception occured ...
        System.exit(1);
    }
}
