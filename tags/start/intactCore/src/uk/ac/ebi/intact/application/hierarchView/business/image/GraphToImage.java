package uk.ac.ebi.intact.application.hierarchView.business.image;

// intact
import uk.ac.ebi.intact.simpleGraph.*;

// hierarchView
import uk.ac.ebi.intact.application.hierarchView.business.graph.*;
import uk.ac.ebi.intact.application.hierarchView.business.PropertyLoader;
import uk.ac.ebi.intact.application.hierarchView.struts.*;
import uk.ac.ebi.intact.application.hierarchView.business.Constants;

// PNG Encoder
import com.keypoint.*;

// JDK
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.util.*;
import java.util.Properties;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.FileOutputStream;
import java.lang.Boolean;


/**
 * This class allows to tranform a graph to an image PNG and a map
 *
 */


public class GraphToImage 
{
  /********** CONSTANTS ************/
  private final static String DEFAULT_BORDER_SIZE  = "5";
  private final static String DEFAULT_IMAGE_LENGTH ="300";
  private final static String DEFAULT_IMAGE_HEIGHT ="300";
  private final static String DEFAULT_MAP_NAME     ="networkMap";

  private final static int DEFAULT_COLOR_BACKGROUND_RED   = 255;
  private final static int DEFAULT_COLOR_BACKGROUND_GREEN = 255;
  private final static int DEFAULT_COLOR_BACKGROUND_BLUE  = 255;
  private final static String DEFAULT_COLOR_BACKGROUND    = DEFAULT_COLOR_BACKGROUND_RED + "," +
                                                            DEFAULT_COLOR_BACKGROUND_GREEN + "," + 
                                                            DEFAULT_COLOR_BACKGROUND_BLUE;

  private final static String DEFAULT_SHAPE_STATE     = "disable";
  private final static String DEFAULT_BORDER_STATE    = "enable";
  private final static int DEFAULT_COLOR_BORDER_RED   = 255;
  private final static int DEFAULT_COLOR_BORDER_GREEN = 255;
  private final static int DEFAULT_COLOR_BORDER_BLUE  = 255;
  private final static String DEFAULT_COLOR_BORDER    = DEFAULT_COLOR_BORDER_RED + "," +
                                                        DEFAULT_COLOR_BORDER_GREEN + "," + 
                                                        DEFAULT_COLOR_BORDER_BLUE;

  private final static String DEFAULT_LABEL_FONT_NAME  = "Arial";
  private final static String DEFAULT_LABEL_FONT_SIZE  = "10";

  private final static String DEFAULT_TEXT_ANTIALIASED = "disable";
  private final static String DEFAULT_NODE_ANTIALIASED = "disable";
  private final static String DEFAULT_EDGE_ANTIALIASED = "disable";

  private final static String DEFAULT_EDGE_THICKNESS = "1.0";

  private final static String DEFAULT_INTERNAL_TOP_MARGIN    = "2";
  private final static String DEFAULT_INTERNAL_BOTTOM_MARGIN = "2";
  private final static String DEFAULT_INTERNAL_LEFT_MARGIN   = "5";
  private final static String DEFAULT_INTERNAL_RIGHT_MARGIN  = "5";

  /********** INSTANCE VARIABLES ************/

  /**
   * Allows to store the HTML MAP code we will use with the image we generate
   */
  private StringBuffer  mapCode = null;

  /**
   * The name of the HTML MAP
   */
  private String mapName;

  /**
   * The generated byte code for the image we want to display
   */
  private byte[] imageData;

  /**
   * allows to know what nodes have been drawn
   */
  private boolean[] drawnNode; 

  /**
   * Object int which we will draw before to convert it in an image
   */
  private BufferedImage graphImage = null;

  /**
   * The Interaction Network graph which will allow to create the image
   */  
  private InteractionNetwork graph = null;

  /**
   * Size of the image
   */
  private float imageSizex;
  private float imageSizey;

  /**
   *  allow to apply a resizing of the image components
   */  
  private float dimensionRateX;
  private float dimensionRateY;

  /**
   * 
   */  
  private float[] marginColor;

  /**
   * 
   */
  private float borderSize;

  /**
   * Internal margin of a node
   */
  private int internalTopMargin, 
              internalBottomMargin, 
              internalLeftMargin, 
              internalRightMargin;

  /**
   * The used font to write the label
   */
  private Font fontLabel;
  private FontMetrics labelFontMetrics;
  
  /**
   * Properties file content
   */
  private Properties properties;

  private Color  backgroundColor;
  private Color  borderColor;
  private String borderEnable;

  private float imageLength, imageHeight;

  private String shapeEnable;

  private String edgeAntialiased;
  private String textAntialiased;
  private String nodeAntialiased;

  private float edgeThickness;



  /**
   * Constructor
   */
  public GraphToImage (InteractionNetwork in)
  {
    this.graph = in;

    // Initialization of mapCode container
    this.mapCode = new StringBuffer();

    // read the ApplicationResource.properties file 
    readPropertyFile ();

    // Compute the size of the final image
    updateProteinData (in);
    
    // Initialization of drawnNode
    int numberOfProtein = in.sizeNodes();
    drawnNode  = new boolean [numberOfProtein];

    for(int k = 0 ; k < numberOfProtein; k++){
      drawnNode[k] = false;
    }

    ImageDimension dimension = in.getImageDimension();

//     // Initialization of dimensionRate, imageSizex and imagesizey
//     if (dimension.length() / imageLength < dimension.height() / imageHeight){
//       this.dimensionRate     = dimension.length() / imageLength;
//       this.imageSizex        = imageLength + borderSize * 2;
//       this.imageSizey        = dimension.height() / dimensionRate + borderSize * 2;
//     } else {
//       this.dimensionRate     = dimension.height() / imageHeight;
//       this.imageSizex        = dimension.length() / dimensionRate  + borderSize * 2;
//       this.imageSizey        = imageHeight + borderSize * 2;
//     }


    // Initialization of dimensionRate, imageSizex and imagesizey
    if (dimension.length() / imageLength < dimension.height() / imageHeight){
      this.dimensionRateX  = dimension.length() / imageLength;
      this.dimensionRateY  = dimension.height() / imageHeight;
      this.imageSizex      = imageLength + borderSize * 2;
      this.imageSizey      = dimension.height() / dimensionRateY + borderSize * 2;
    } else {
      this.dimensionRateX  = dimension.length() / imageLength;
      this.dimensionRateY  = dimension.height() / imageHeight;
      this.imageSizex      = dimension.length() / dimensionRateX  + borderSize * 2;
      this.imageSizey      = imageHeight + borderSize * 2;
    }



//     System.out.println ("numberOfProtein = " + numberOfProtein);
//     System.out.println ("this.dimensionRateX = " + this.dimensionRateX);
//     System.out.println ("this.dimensionRateY = " + this.dimensionRateY);
//     System.out.println ("dimension.length() = " + dimension.length() );
//     System.out.println ("dimension.height() = " + dimension.height());
//     System.out.println ("borderSize = " + borderSize);
//     System.out.println ("imageLength = " + imageLength);
//     System.out.println ("imageHeight = " + imageHeight);
//     System.out.println ("imageSizex = "+imageSizex);
//     System.out.println ("imageSizey = "+imageSizey);


  } // GraphToImage
  


  /**
   * Compute the size of the final image according to proteins data (coordinates, size)
   *
   */
  private void updateProteinData (InteractionNetwork in) {

    // ArrayList listOfProtein     = (ArrayList) graph.getNodes();

    ArrayList listOfProtein     = (ArrayList) graph.getOrderedNodes();
    int numberOfProtein = in.sizeNodes();
    // Protein protein;
    Node protein;

    // Create a fake image to calculate the dimension of the final image.
    graphImage = new  BufferedImage((int) 1, 
				    (int) 1, 
				    BufferedImage.TYPE_BYTE_INDEXED); 
 
    Graphics2D g = graphImage.createGraphics();
    g.setFont (fontLabel);
    this.labelFontMetrics = g.getFontMetrics ();

    ImageDimension dimension = in.getImageDimension();
    int j;

    // Update the image dimension according to the proteins coordinates
    for (j = 0; j < numberOfProtein; j++) {
      protein = (Node) listOfProtein.get(j);

      if (((Boolean) protein.get(Constants.ATTRIBUTE_VISIBLE)).booleanValue() == true) {
	// get the protein label
	String proteinLabel  = protein.getLabel();

	// get Tulip coordinate
	float proteinX = ((Float) protein.get(Constants.ATTRIBUTE_COORDINATE_X)).floatValue();
	float proteinY = ((Float) protein.get(Constants.ATTRIBUTE_COORDINATE_Y)).floatValue();

	// update the image dimansion
	dimension.adjust (proteinX, proteinY);
      }
    } // for


    // update the image dimension according to the proteins coordinates and their size's shape
    for (j = 0; j < numberOfProtein; j++) {
      protein = (Node) listOfProtein.get(j);

      if (((Boolean) protein.get(Constants.ATTRIBUTE_VISIBLE)).booleanValue() == true) {
	// get the protein label
	String proteinLabel  = protein.getLabel();
	
	// get Tulip coordinate
	float proteinX       = ((Float) protein.get(Constants.ATTRIBUTE_COORDINATE_X)).floatValue();
	float proteinY       = ((Float) protein.get(Constants.ATTRIBUTE_COORDINATE_Y)).floatValue();

	// calculate heigth and width
	float height = this.labelFontMetrics.getHeight() + 
	               this.internalTopMargin + 
	               this.internalBottomMargin;
	float length = this.labelFontMetrics.stringWidth(proteinLabel) + 
                       this.internalLeftMargin + 
                       this.internalRightMargin;

	// update data in the protein
	protein.put (Constants.ATTRIBUTE_LENGTH, new Float (length));
	protein.put (Constants.ATTRIBUTE_HEIGHT, new Float (height));

	// update the image dimension according to the proteine shape size
	dimension.adjustCadre (length, height, proteinX, proteinY);
      }
    } //  for

    graphImage = null;

  } // updateProteinData



  /**
   * Read all the needed properties and store the values int instance variable.
   * it allows to avoid to scatter this code int the drawing code.
   */
  private void readPropertyFile () {

    this.properties = PropertyLoader.load (Constants.PROPERTY_FILE);

    // read the background and border color in the property file
    String stringBgColor     = null;
    String stringBorderColor = null;

    String border       = null;
    String xSize        = null;
    String ySize        = null;
    String fontName     = null;
    String fontSize     = null;
    int    intFontSize  = 0;
    String thicknessStr = null;

    String internalTopMarginStr    = null;
    String internalBottomMarginStr = null;
    String internalLeftMarginStr   = null;
    String internalRightMarginStr  = null;
    this.internalTopMargin = 0;
    this.internalBottomMargin = 0; 
    this.internalLeftMargin = 0;
    this.internalRightMargin = 0;

    this.borderEnable    = null;
    this.nodeAntialiased = null;
    this.mapName         = null;
    this.edgeAntialiased = null;
    this.textAntialiased = null;
    this.shapeEnable     = null;



    // read all the needed properties in the file
    if (null != this.properties) {
      stringBgColor             = properties.getProperty ("hierarchView.image.color.default.background");
      stringBorderColor         = properties.getProperty ("hierarchView.image.color.default.border");
      this.borderEnable         = properties.getProperty ("hierarchView.image.border");
      border                    = properties.getProperty ("hierarchView.image.size.default.border");
      xSize                     = properties.getProperty ("hierarchView.image.size.default.image.length");
      ySize                     = properties.getProperty ("hierarchView.image.size.default.image.height");
      fontName                  = properties.getProperty ("hierarchView.image.font.name.label");
      fontSize                  = properties.getProperty ("hierarchView.image.font.size.label");
      this.mapName              = properties.getProperty ("hierarchView.image.map.name");
      this.edgeAntialiased      = properties.getProperty ("hierarchView.image.edge.antialiased");
      this.textAntialiased      = properties.getProperty ("hierarchView.image.font.antialiased");
      thicknessStr              = properties.getProperty ("hierarchView.image.edge.thickness");
      this.nodeAntialiased      = properties.getProperty ("hierarchView.image.node.antialiased");
      this.shapeEnable          = properties.getProperty ("hierarchView.image.shape");
      internalTopMarginStr      = properties.getProperty ("hierarchView.image.node.internalTopMargin");
      internalBottomMarginStr   = properties.getProperty ("hierarchView.image.node.internalBottomMargin"); 
      internalLeftMarginStr     = properties.getProperty ("hierarchView.image.node.internalLeftMargin");
      internalRightMarginStr    = properties.getProperty ("hierarchView.image.node.internalRightMargin");
    }

    if (null == stringBgColor) {
      stringBgColor = DEFAULT_COLOR_BACKGROUND;
    }

    this.backgroundColor = Utilities.parseColor (stringBgColor, 
						 DEFAULT_COLOR_BACKGROUND_RED,
						 DEFAULT_COLOR_BACKGROUND_GREEN,
						 DEFAULT_COLOR_BACKGROUND_BLUE);

    if (null == this.borderEnable) {
      this.borderEnable = DEFAULT_BORDER_STATE;
    }

    this.borderColor = Utilities.parseColor (stringBorderColor, 
					     DEFAULT_COLOR_BORDER_RED,
					     DEFAULT_COLOR_BORDER_GREEN,
					     DEFAULT_COLOR_BORDER_BLUE);     
    if (null == border) {
      border = DEFAULT_BORDER_SIZE;
      /*error log*/
    }
    
    if (null == xSize) {
      xSize = DEFAULT_IMAGE_LENGTH;
      /*error log*/
    }
    
    if (null == ySize) {
      ySize = DEFAULT_IMAGE_HEIGHT;
      /*error log*/
    }
    
    if (null == this.mapName) {
      mapName = DEFAULT_MAP_NAME;
      /*error log*/
    }

    if (null == fontName) {
      fontName = DEFAULT_LABEL_FONT_NAME;
      /*error log*/
    }

    if (null == fontSize) {
      fontSize = DEFAULT_LABEL_FONT_SIZE;
      /*error log*/
    } else {
      try {
	intFontSize = Integer.parseInt(fontSize);
      } catch (NumberFormatException nfe) {
	// parse the default value
	intFontSize = Integer.parseInt(DEFAULT_LABEL_FONT_SIZE);
	/*error log*/
      }
    }
 
    this.fontLabel = new Font (fontName, Font.PLAIN, intFontSize); 
    this.borderSize = (new Float(border)).floatValue();
    this.imageLength     = (new Float(xSize)).floatValue();
    this.imageHeight     = (new Float(ySize)).floatValue();

    if (null == this.edgeAntialiased) {
      /* Log error */
      this.edgeAntialiased = DEFAULT_EDGE_ANTIALIASED;
    }
    
    if (null == this.textAntialiased) {
      /* Log error */
      this.textAntialiased = DEFAULT_TEXT_ANTIALIASED;
    }

    if (null == thicknessStr) {
      /* Log error */
      thicknessStr = DEFAULT_EDGE_THICKNESS;
    }

    try {
      this.edgeThickness = Float.parseFloat (thicknessStr);
    } catch (NumberFormatException nfe) {
      this.edgeThickness = Float.parseFloat (DEFAULT_EDGE_THICKNESS);
    }

    if (null == this.nodeAntialiased) {
      /* Log error */
      this.nodeAntialiased = DEFAULT_NODE_ANTIALIASED;
    }

    if (null == this.shapeEnable) {
      /* Log error */    
      this.shapeEnable = DEFAULT_SHAPE_STATE;
    }

    if (null == internalTopMarginStr) {
      /* Log error */    
      this.internalTopMargin = Integer.parseInt (DEFAULT_INTERNAL_TOP_MARGIN);
    } else {
      try {
	this.internalTopMargin = Integer.parseInt (internalTopMarginStr);
      } catch (NumberFormatException nfe) {
	this.internalTopMargin = Integer.parseInt (DEFAULT_INTERNAL_TOP_MARGIN);
      }
    }

    if (null == internalBottomMarginStr) {
      /* Log error */    
      this.internalBottomMargin = Integer.parseInt (DEFAULT_INTERNAL_BOTTOM_MARGIN);
    } else {
      try {
	this.internalBottomMargin = Integer.parseInt (internalBottomMarginStr);
      } catch (NumberFormatException nfe) {
	this.internalBottomMargin = Integer.parseInt (DEFAULT_INTERNAL_BOTTOM_MARGIN);
      }
    }

    if (null == internalLeftMarginStr) {
      /* Log error */    
      this.internalLeftMargin = Integer.parseInt (DEFAULT_INTERNAL_LEFT_MARGIN);
    } else {
      try {
	this.internalLeftMargin = Integer.parseInt (internalLeftMarginStr);
      } catch (NumberFormatException nfe) {
	this.internalLeftMargin = Integer.parseInt (DEFAULT_INTERNAL_LEFT_MARGIN);
      }
    }

    if (null == internalRightMarginStr) {
      /* Log error */    
      this.internalRightMargin = Integer.parseInt (DEFAULT_INTERNAL_RIGHT_MARGIN);
    } else {
      try {
	this.internalRightMargin = Integer.parseInt (internalRightMarginStr);
      } catch (NumberFormatException nfe) {
	this.internalRightMargin = Integer.parseInt (DEFAULT_INTERNAL_RIGHT_MARGIN);
      }
    }

  } // readPropertyFile


  /**
   * Give the color to apply for the label
   *
   * @param x The node color corresponding to the label
   * @return float
   */
  private float labelColor(float x){
    float y = (marginColor[1]-marginColor[0])/2;
    if(x < marginColor[0] + y)
      return x + y;
    else return x - y;
  }
  
  /**
   * Adjust the color
   *
   * @param color The color to adjust
   * @return float
   */
  private float  adjustColor(float color){
    return (marginColor[0] + color*(marginColor[1] - marginColor[0])/1000);
  }

  /**
   * Return the element "dimensionRate"
   *
   * @return the dimension rate 
   */
  private float getDimensionRateX(){
    return dimensionRateX;
  } 
  
  private float getDimensionRateY(){
    return dimensionRateY;
  }

  /**
   * Modify the coordinate for an edge. This modification allows to create a boder in the image
   *
   * @param x The old coordinate
   * @param length The length
   * @param rate The rate
   *
   * @return float
   */
  private float newCoordinateEdge(float x, float length, float rate){
    return x + length / (2 * rate); //for the border
  }
  

  
  /**
   * Modify the coordinate for a node. This modification allow to create a boder in the image
   * a shift is applied to coordinates x and y
   *
   * @param old The old coordinate
   * @param xmin The coordinate x minimal in the graph
   * @param length The length
   * @param rate The rate
   *
   * @return the new coordinate
   */
  private float newCoordinateNode (float old, float xmin, float length, float rate)
  {
    return (old - xmin - length/2) / rate + borderSize;
  } 
  
  
  /**
   * Allows to draw an element "node" in the image
   *
   * @param protein The protein to draw
   * @param g The graphic where we draw
   */
  private void drawNode(Node protein, Graphics2D g) {

    String proteinLabel  = protein.getLabel();

    System.out.println("proteinLabel = " + proteinLabel);
    float proteinLength  = ((Float) protein.get(Constants.ATTRIBUTE_LENGTH)).floatValue();
    float proteinHeight  = ((Float) protein.get(Constants.ATTRIBUTE_HEIGHT)).floatValue();
    float proteinX       = ((Float) protein.get(Constants.ATTRIBUTE_COORDINATE_X)).floatValue();
    float proteinY       = ((Float) protein.get(Constants.ATTRIBUTE_COORDINATE_Y)).floatValue();

    ImageDimension dimension = graph.getImageDimension();

    float x1            = newCoordinateNode (proteinX, 
					     dimension.xmin(), 
					     proteinLength ,
					     getDimensionRateX());

    float y1            = newCoordinateNode (- proteinY, 
					     - (dimension.height() + dimension.ymin()), 
					     proteinHeight, 
					     getDimensionRateY());

    x1 -= proteinLength / 4;
    y1 -= proteinHeight / 4;

    int x2 = (int) x1 + ((int) proteinLength); 
    int y2 = (int) y1 + ((int) proteinHeight);

    if (this.nodeAntialiased.equalsIgnoreCase ("enable")) {
      // Enable antialiasing for shape
      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
			 RenderingHints.VALUE_ANTIALIAS_ON);
    }    
    

    if (this.shapeEnable.equalsIgnoreCase ("enable")) {
      Color colorNode = (Color) protein.get(Constants.ATTRIBUTE_COLOR_NODE);
      g.setColor(colorNode);
    } else {
      // create a transparent color to allow to see edges
      Color bg = new Color ( this.backgroundColor.getRed (),
			     this.backgroundColor.getGreen (),
			     this.backgroundColor.getBlue (),
			     180); // opacity : 0=transparent, 255=opaque

      // dont display the node but clear edges to display label
      g.setColor(bg);
    }


    g.fillOval ((int) x1,
		(int) y1, 
		(int) proteinLength, 
		(int) proteinHeight); 

    // In anycase turn the shape antialiasing off.
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
		       RenderingHints.VALUE_ANTIALIAS_OFF);

    // Write the map
    mapCode.append("<AREA SHAPE=\"RECT\" HREF=\"/hierarchView/centered.do?AC=" + protein.getAc() + 
		   " \" COORDS=" + (int)x1 + "," + (int)y1 + "," + x2 + "," + y2 + ">");

    // Write label
    g.setFont (fontLabel);
    Color colorLabel = (Color) protein.get(Constants.ATTRIBUTE_COLOR_LABEL);
    g.setColor (colorLabel);
    
    g.drawString (proteinLabel,
		  (int) x1 + this.internalLeftMargin,
		  (int) (y1 + proteinHeight / 2) + this.internalTopMargin);

    // set the protein as drawn
    ArrayList listOfProteins = (ArrayList) graph.getOrderedNodes();
    drawnNode[listOfProteins.indexOf(protein)] = true;	 

  } // drawNode
  
  

  /**
   * Allows to draw an element "edge" in the image
   *
   * @param interaction The interaction to draw
   * @param g The graphic where we draw
   */
  private void drawEdge(EdgeI interaction, Graphics2D g)
  {
    Node proteinR, proteinL;
    float xline1, xline2, yline1, yline2;

    float proteinRx, proteinRy, 
          proteinRlength, proteinRheight, 
          proteinLx, proteinLy, 
          proteinLlength, proteinLheight; 
    Color proteinRcolorNode, proteinLcolorNode;
    int proteinRred, proteinRgreen, proteinRblue, proteinRalpha, 
        proteinLred, proteinLgreen, proteinLblue, proteinLalpha;

    ImageDimension dimension = graph.getImageDimension();
    
    // proteinRight
    proteinR           = (Node) interaction.getNode1();
    proteinRx          = ((Float) proteinR.get(Constants.ATTRIBUTE_COORDINATE_X)).floatValue();
    proteinRy          = ((Float) proteinR.get(Constants.ATTRIBUTE_COORDINATE_Y)).floatValue();
    proteinRlength     = ((Float) proteinR.get(Constants.ATTRIBUTE_LENGTH)).floatValue();
    proteinRheight     = ((Float) proteinR.get(Constants.ATTRIBUTE_HEIGHT)).floatValue();
    proteinRcolorNode  = (Color) proteinR.get(Constants.ATTRIBUTE_COLOR_NODE);

    // proteinLeft
    proteinL           = (Node) interaction.getNode2();
    proteinLx          = ((Float) proteinL.get(Constants.ATTRIBUTE_COORDINATE_X)).floatValue();
    proteinLy          = ((Float) proteinL.get(Constants.ATTRIBUTE_COORDINATE_Y)).floatValue();
    proteinLlength     = ((Float) proteinL.get(Constants.ATTRIBUTE_LENGTH)).floatValue();
    proteinLheight     = ((Float) proteinL.get(Constants.ATTRIBUTE_HEIGHT)).floatValue();
    proteinLcolorNode  = (Color) proteinL.get(Constants.ATTRIBUTE_COLOR_NODE);


    // calcul
    xline1 = newCoordinateEdge(
			       newCoordinateNode(proteinRx,
						 dimension.xmin(), 
						 proteinRlength,
						 getDimensionRateX()),
			       proteinRlength,
			       getDimensionRateX());
    
    xline2 = newCoordinateEdge(
			       newCoordinateNode(proteinLx,
						 dimension.xmin(), 
						 proteinLlength,
						 getDimensionRateX()), 
			       proteinLlength, 
			       getDimensionRateX());

    yline1 = newCoordinateEdge(
			       newCoordinateNode(- proteinRy, 
						 -(dimension.height() + dimension.ymin()),
						 proteinRheight, 
						 getDimensionRateY()) , 
			       proteinRheight, 
			       getDimensionRateY());

    yline2 = newCoordinateEdge(
			       newCoordinateNode(- proteinLy, 
						 -(dimension.height() + dimension.ymin()),
						 proteinLheight, 
						 getDimensionRateY()), 
			       proteinLheight, 
			       getDimensionRateY());


    if (this.edgeAntialiased.equalsIgnoreCase ("enable")) {
      // Enable antialiasing for shape
      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
			 RenderingHints.VALUE_ANTIALIAS_ON);
    }  

    // These color are different ?
    boolean applyGradient = !(proteinRcolorNode.equals ( proteinLcolorNode ));
    Paint defaultGradient = null;

    if (true == applyGradient) {
      // Create a non-cyclic gradient
      GradientPaint gradient = new GradientPaint(xline1, yline1, proteinRcolorNode, 
						 xline2, yline2, proteinLcolorNode);
      defaultGradient = g.getPaint();
      g.setPaint(gradient);
    } else {
      g.setColor (proteinRcolorNode);
    }
    
    // draw the edge
    g.drawLine((int)xline1, 
	       (int)yline1,
	       (int)xline2, 
	       (int)yline2);
  
    // In anycase turn the antialiasing off.
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
		       RenderingHints.VALUE_ANTIALIAS_OFF);
    
    if (true == applyGradient) {
      // set the default gradient
      g.setPaint(defaultGradient);
    }    

  }// drawEdge
  

  /**
   * drawing process, call methods to draw nodes, edges ...
   *
   */
  public void draw() throws IOException
  {
    int i;
    int numberOfProtein         = graph.sizeNodes();
    int numberOfInteraction     = graph.sizeEdges();

    ArrayList listOfProtein     = (ArrayList) graph.getOrderedNodes();
    Vector listOfInteraction = (Vector) graph.getEdges();

    EdgeI interaction;
    Node proteinR, proteinL;
    Graphics2D  g;


    graphImage = new  BufferedImage((int)imageSizex, 
				    (int)imageSizey, 
				    BufferedImage.TYPE_BYTE_INDEXED); 
 
    g = graphImage.createGraphics();

    // Display the background  
    g.setColor (this.backgroundColor);
    g.fillRect ((int) 0,
		(int) 0, 
		(int) imageSizex, 
		(int) imageSizey); 
    
    if (textAntialiased.equalsIgnoreCase ("enable")) {
      // Enable antialiasing for text
      g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
			 RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    } else {
      // Disable antialiasing for text
      g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
			 RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    }
    
    Stroke defaultStroke = g.getStroke ();
    BasicStroke stroke   = new BasicStroke (this.edgeThickness);
    g.setStroke (stroke);

    // We draw edges whose nodes are visible
    for(i = 0; i < numberOfInteraction; i++) {
      interaction = (EdgeI) listOfInteraction.get(i);
      
      proteinR    = (Node) interaction.getNode1();
      proteinL    = (Node) interaction.getNode2();
      
      if (((Boolean) proteinR.get(Constants.ATTRIBUTE_VISIBLE)).booleanValue() == true && 
	  ((Boolean) proteinL.get(Constants.ATTRIBUTE_VISIBLE)).booleanValue() == true) {
	drawEdge(interaction, g);
      }
    } // for

    // restore the default Stroke (thickness)
    g.setStroke (defaultStroke);


    Node tmp;
   
    // We draw all visible nodes

    mapCode.append("<MAP NAME=\"" + mapName + "\">");

    for(int j = 0; j < numberOfProtein; j++) {
      tmp = (Node) listOfProtein.get(j);
      if(drawnNode[j] == false && 
	 ((Boolean) tmp.get(Constants.ATTRIBUTE_VISIBLE)).booleanValue() == true) {
	drawNode(tmp, g);
      }
    }
    
    mapCode.append("</MAP>");

    if (this.borderEnable.equals("enable")) {
      g.setColor (borderColor);
      g.drawRect ((int) 0,
		  (int) 0, 
		  (int) imageSizex - 1, 
		  (int) imageSizey - 1);
    }

    g.drawImage(graphImage, 0, 0, this.backgroundColor, null);
  
  } // draw
  
  
  /**
   * Generate the image data and put it into a bean with the corresponding HTML MAP code.
   * We use the classes already developped by M. David Eisenberg and being a free using.
   * We can find its on the web site : http://www.catcode.com/pngencoder/.
   * 
   * @return the bean initialized with the image and the MAP code. null if an error occured.
   */
  public ImageBean getImageBean () {
    
    PngEncoder png = new PngEncoder( graphImage, false, 0, 0);
    imageData      = png.pngEncode();

    if (null == imageData)
	return null;

    ImageBean ib = new ImageBean ();
    ib.setMapCode(mapCode.toString());
    ib.setImageData(imageData);
    return ib;
  } // getImageBean


}// GraphToImage










