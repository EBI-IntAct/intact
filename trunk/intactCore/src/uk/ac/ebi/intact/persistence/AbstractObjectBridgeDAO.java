/*
Copyright (c) 2002 The European Bioinformatics Institute, and others.
All rights reserved. Please see the file LICENSE
in the root directory of this distribution.
*/

package uk.ac.ebi.intact.persistence;

import org.apache.log4j.Logger;
import org.apache.ojb.broker.*;
import org.apache.ojb.broker.accesslayer.LookupException;
import org.apache.ojb.broker.accesslayer.OJBIterator;
import org.apache.ojb.broker.metadata.*;
import org.apache.ojb.broker.metadata.fieldaccess.PersistentField;
import org.apache.ojb.broker.query.*;
import uk.ac.ebi.intact.model.proxy.IntactObjectProxy;

import java.sql.Connection;
import java.util.*;

/**
 * This is the super class for ObjectBridge-specific Data Access Object, which
 * effectively wraps up an ObjectBridge broker object.
 *
 * @author Sugath Mudali
 * @version $Id$
 */

public abstract class AbstractObjectBridgeDAO implements DAO {

    /**
     * The name of the logger.
     */
    private static final String OJB_LOGGER_NAME = "ojb";

    /**
     * A log utility, used if required. Allow logging by the sub classes.
     */
    protected static Logger ourLogger;

    /**
     * holds the instance of the Database (ie a connection)
     * NB this is not serializable!!
     */
    private transient PersistenceBroker myBroker;

    /**
     * cache to be used for caching by unique search parameters. The parameter
     * is the key, and the value is the key used by the OJB cache.
     */
    private Map myCache = new HashMap();

    /**
     * determines which classes are to be cached.
     */
    private Set cachedClasses = new HashSet();

    public AbstractObjectBridgeDAO(PersistenceBroker broker) {
        myBroker = broker;
        // set up the logging facilities
        ourLogger = Logger.getLogger(OJB_LOGGER_NAME);
    }

    /**
     * Method to release result resources (eg result set). An IllegalArgumentException
     * is thronw if the iterator supplied has not been generated by use of iteratorFind.
     *
     * @param itemIterator The iterator over the results (should be obtained from iteratorFind)
     * @throws IllegalArgumentException thrown if the Iterator is an invalid type
     */
    public void closeResults(Iterator itemIterator) {
        if (!(itemIterator instanceof OJBIterator)) {
            throw new IllegalArgumentException("parameter must be a valid Iterator generated from iteratorFind");
        }
        OJBIterator ojbIter = (OJBIterator) itemIterator;
        ojbIter.releaseDbResources();

    }

    /**
     * changes the username and password details used for connection.
     * Note that this is NOT currently a runtime change, but will change
     * to a different user if eg the DAO is serialized. This may be modified
     * later to (if possible) provide runtime user switching.
     *
     * @param user the new username
     * @param password the new user password
     */
    public void resetUserInfo(String user, String password) {
        MetadataManager metaData = MetadataManager.getInstance();
        PBKey pbkey = null;
        if (user == null) {
            pbkey = metaData.getDefaultPBKey();
        }
        else {
            PBKey defaultKey = metaData.getDefaultPBKey();
            JdbcConnectionDescriptor defaultDbDescriptor =
                    metaData.connectionRepository().getDescriptor(defaultKey);
            String jcdAlias = defaultDbDescriptor.getJcdAlias();
            pbkey = new PBKey(jcdAlias, user, password);
        }
        // Release the previous broker back to the pool (or GCed).
        myBroker.close();
        myBroker = PersistenceBrokerFactory.createPersistenceBroker(pbkey);
    }

    public void addCachedClass(Class clazz) {
        cachedClasses.add(clazz);
    }

    public boolean isCachedClass(Class clazz) {
        return cachedClasses.contains(clazz);
    }

    public void clearCache() throws PersistenceBrokerException {
        myBroker.clearCache();
    }

    public void setLogger(Logger p) {
        ourLogger = p;
    }

    /**
     * validates a username and password against the datastore.
     *
     * @return boolean true if user credentials are valid, false if not or if a null username is supplied.
     */
    public boolean isUserValid(String userName, String password) {
        //NB simple validation for now, probably to be enhanced later -
        //just validate against user details in OJB repository.xml..
        if (userName == null) {
            return false;
        }
        String knownUser = myBroker.getPBKey().getUser();
        String knownPassword = myBroker.getPBKey().getPassword();
        if (knownUser.equals(userName)) {
            //check password - could be null..
            return (((password == null) && (knownPassword == null)) ||
                    (knownPassword.equals(password)));
        }
        return false;
    }

    /**
     * Provides the database name that is being connected to.
     *
     * @return String the database name, or an empty String if the query fails
     */
    public String getDbName() {
        MetadataManager meta = MetadataManager.getInstance();
        PBKey pbkey = meta.getDefaultPBKey();
        JdbcConnectionDescriptor jDesc = meta.connectionRepository().getDescriptor(pbkey);
        if (jDesc.getDbAlias() != null) {
            return jDesc.getDbAlias();
        }
        return "";
    }

    /**
     * Provides the user name that is connecting to the DB.
     *
     * @return String the user name, or an empty String if the query fails
     */
    public String getDbUserName() {
        return myBroker.getPBKey().getUser();
    }

    /**
     * Method to get a direct SQL connection which can be used by JDBC
     *
     * @return java.sql.Connection to database
     * @throws org.apache.ojb.broker.accesslayer.LookupException
     */
    public Connection getJDBCConnection() throws LookupException {
        return myBroker.serviceConnectionManager().getConnection();
    }

    public void close() throws DataSourceException {
        // DataSourceException is not thrown from here but it may be thrown from
        // a subclass.
        myBroker.close();
    }

    /**
     * opens a DAO (connection). Note that connections are opened also via
     * the DAO constructor method, so this method should not be called unless
     * a previous call to close() has been made.
     *
     * @throws DataSourceException - thrown if the DAO cannot be closed (details in specific errors)
     */
    public void open() throws DataSourceException {
        throw new DataSourceException("Not implemented");
    }

    public void removeFromCache(Object obj) {
        myBroker.removeFromCache(obj);
    }

    public void removeFromCache(Class realClass, String ac) {
        removeFromCache(new Identity(realClass, myBroker.getTopLevelClass(realClass),
                new Object[] {ac}));
    }

    public boolean isInCache(Class realClass, String ac) {
        Identity id = new Identity(realClass, myBroker.getTopLevelClass(realClass),
                new Object[] {ac});
        return myBroker.serviceObjectCache().lookup(id) != null;
    }

    /**
     * checks to see if object saving automatically is turned on
     *
     * @return boolean - true if auto saving is on, false otherwise
     */
//    public boolean isAutoSave() {
//        MetadataManager meta = MetadataManager.getInstance();
//        PBKey pbkey = meta.getDefaultPBKey();
//        JdbcConnectionDescriptor jDesc = meta.connectionRepository().getDescriptor(pbkey);
//        return jDesc.getUseAutoCommit() == 1;
//    }

    /**
     * sets whether or not auto saving is turned on
     *
     * @param val - true to turn on, false for off
     */
//    public void setAutoSave(boolean val) {
//        try {
//            myBroker.serviceConnectionManager().getConnection().setAutoCommit(val);
//        }
//        catch (LookupException se) {
//            ourLogger.error("unable to reset autocommit value - reset failed", se);
//        }
//        catch (SQLException sqle) {
//            ourLogger.error("unable to reset autocommit value - reset failed", sqle);
//        }
//    }

    /**
     * checks to determine if a given object is persistent or not
     *
     * @param obj - the object to be checked
     * @return boolean - true if the object is persistent (default), false for
     *         all other instances.
     */
    public boolean isPersistent(Object obj) {
        // Check for the proxy first; if it is an Intact proxy, we assume it is a
        // persistent class.
        if (IntactObjectProxy.class.isAssignableFrom(obj.getClass())) {
            return true;
        }
        ClassDescriptor cldes = null;
        try {
            cldes = getClassDescriptor(obj.getClass());
        }
        catch (ClassNotPersistenceCapableException cnpce) {
            return false;
        }
        Object pkvalue = cldes.getPkFields()[0].getPersistentField().get(obj);
        if (pkvalue == null) {
            // Doesn't exist in the database
            return false;
        }
        // Got a non null primary key. However, the object in between create and
        // commit (e.g., object created and not comitted in a transaction).
        // Check for real by querying the database with an Identity.
        Identity ident = new Identity(obj, myBroker);
        Object dummy = myBroker.getObjectByIdentity(ident);
        if (dummy == null) {
            return false;
        }
        return true;
    }

    public Collection find(String type, String col, String val) throws SearchException {
        try {
            return find(Class.forName(type), col, val);

        }
        catch (ClassNotFoundException c) {
            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            ourLogger.info(msg);
            throw new SearchException(msg, c);
        }
    }

    /**
     * <p>This method searches the DB based on the information in the
     * parameters. Note that this only supports a single parameter
     * (simple) search at present - bulk searches are TBD </p>
     *
     * @param searchClass - the class to be searched
     * @param col - the parameter (column name) to search on (usually ac number or name)
     * @param val - the value of the search parameter. If null, then all items matching the class name will be returned
     * @return a collection containing the results of the searches
     * @throws SearchException -  thrown for errors during the search process, eg query problems
     * @throws NullPointerException thrown if the type is not specified
     */
    public <T> Collection<T> find(Class<T> searchClass, String col, String val) throws SearchException {
        Collection results = new ArrayList();

        //debug info..
        long timer = 0;

        if (col == null) {
            //no table column
            String msg = "search failed: no search parameter specified in request";
            ourLogger.info(msg);
            throw new SearchException(msg);
        }

        try {
            //should now call getConcreteClasses to obtain the concrete
            //Class instances we should build if necessary....
            Collection classesToSearch = getConcreteClasses(searchClass);

            Criteria crit = null;

            //check local cache first for the object, in case the col is not the PK
            if (isCachedClass(searchClass)) {

                ourLogger.info("search class may be unique by criteria other than PK - trying local cache...");

                Object obj = myCache.get(searchClass + "-" + col + "-" + val);

                if (obj != null) {

                    ourLogger.debug("class " + obj.getClass().getName() + " found in local cache");
                    ourLogger.debug("returning locally cached object as find result - class: " + obj.getClass().getName());
                    //as obj is unique, we are done
                    results.add(obj);
                    return results;

                }
            }
            //build a normal Criteria query, if class is cached locally or not (
            //if found locally, would have returned by here)
            if (val != null) {
                crit = new Criteria();
                //crit.addEqualTo(col, val);
                addSearchClause(crit, col, val);
            }

            ourLogger.info("criteria built OK");
            //now build a query for each search class...
            Collection queries = new ArrayList(classesToSearch.size());
            Criteria typeCriteria = null;
            for (Iterator it = classesToSearch.iterator(); it.hasNext();) {
                //query = new QueryByCriteria(searchClass, crit);
                Class clazz = (Class) it.next();
                //each type to search may be different - get the info and use it
                String concreteType = clazz.getName();
                //System.out.println("concrete type to be searched: " + concreteType);
                Criteria queryCriteria = new Criteria(); //holds all the search criteria
                //if (val != null) queryCriteria.addEqualTo(col, val);
                if (val != null) addSearchClause(queryCriteria, col, val);
                //check to see if the table holds multiple object types,
                //and add an extra criteria if so
                if (isTypeNeeded(concreteType)) {
                    typeCriteria = new Criteria();
                    //add the type info, then add the value info if it was given
                    typeCriteria.addEqualTo(ClassDescriptor.OJB_CONCRETE_CLASS, concreteType);
                    // this works!! if (val != null) typeCriteria.addEqualTo(col, val);

                    //BUT for 'older' data the classname in the DB may not
                    //have the 'Impl' at the end, so we need to check for those
                    //too....

                    // TODO: NullPointerException can occur here !
                    // TODO: If a concrete class don't have Impl as suffix, it fails.
                    int index = concreteType.indexOf("Impl");
                    if (index != -1) {
                        String oldType = concreteType.substring(0, index);
                        //System.out.println("old type name: " + oldType);
                        Criteria oldTypeCriteria = new Criteria();
                        oldTypeCriteria.addEqualTo(ClassDescriptor.OJB_CONCRETE_CLASS, oldType);
                        typeCriteria.addOrCriteria(oldTypeCriteria);
                    }



                    //now add the type info to the query criteria
                    queryCriteria.addAndCriteria(typeCriteria);
                    //System.out.println("Query built for " + concreteType + ":");
                    //Query dummy = new QueryByCriteria(clazz, typeCriteria);
                    Query dummy = new QueryByCriteria(clazz, queryCriteria);
                    //printQuery(dummy);  //debug
                    queries.add(dummy);
                }
                else {
                    //normal query
                    queries.add(new QueryByCriteria(clazz, crit));
                }
            }
            ourLogger.info("query by criteria built OK: " + col + " " + val);

            //simple timing
            //System.gc();
            long tmp = System.currentTimeMillis();
            //System.gc();
            timer = System.currentTimeMillis();

            for (Iterator queryIt = queries.iterator(); queryIt.hasNext();) {
                results.addAll(myBroker.getCollectionByQuery((Query) queryIt.next()));
            }

            tmp = System.currentTimeMillis();
            timer = tmp - timer;
            ourLogger.info("******************************************");
            ourLogger.info("time in OJB query execute (ms): " + timer);
            ourLogger.info("******************************************");

        }
        catch (PersistenceBrokerException pbe) {
            pbe.printStackTrace();
            //problem doing the query....
            String msg = "search failed: problem executing query";
            ourLogger.info(msg);
            //NB with the Collection of queries the debug below needs modifying...
//            logger.info("Criteria: " + query.getCriteria().toString() + "\n");
//            logger.info("class: " + query.getSearchClass().getName() + "\n");
//            logger.info("attribute requested: " + query.getRequestedAttribute() + "\n");
            throw new SearchException(msg, pbe);
        }

        //Possible that only PROXIES have been returned - if so then we
        //should really return the concrete classes instead (we only need proxies
        //inside an object's own collections - currently (!)...
        Collection finalResults = checkProxies(results);

        if ((isCachedClass(searchClass)) & (!results.isEmpty())) {

            //must have a unique result that could be queried other than by PK, so cache it locally
            Iterator it = finalResults.iterator();
            Object obj = it.next();
            if (it.hasNext()) {

                //some problem - expecting a unique result...
                throw new SearchException("search error - expecting a unique result but got more than one");
            }
            myCache.put(searchClass + "-" + col + "-" + val, obj);
        }

        return finalResults;
    }

    /**
     * @see DAO
     *      Note: the local cache of non-PK fields is not currently used in this method (to do)
     */
    public Collection find(Object obj) throws SearchException {

        //IMPORTANT!! OJB queryByExample only works on IDs again, ie it is not a "real"
        //search by object. If the example has no ID set it returns all for that class.
        //see private method buildQueryByExample for an attempt to do it properly.....

//        checkForOpenStore();
        Query query = null;
        Collection results = new ArrayList();

        //debug info..
        long timer = 0;

        //first check the param
        if (obj == null) {

            //no search value
            String msg = "search failed: no search value specified in request";
            ourLogger.info(msg);
            throw new SearchException(msg);
        }

        try {

            query = buildQueryByExample(obj);
            ourLogger.info("query by example built OK");

            timer = System.currentTimeMillis();

            //get a Collection - may be more than one object matching the example
            results = myBroker.getCollectionByQuery(query);

            long tmp = System.currentTimeMillis();
            timer = tmp - timer;
            ourLogger.info("******************************************");
            ourLogger.info("search by object: time in OJB query execute (ms): " + timer);
            ourLogger.info("******************************************");

        }
        catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem executing query " + query.toString();
            ourLogger.info(msg);
            throw new SearchException(msg, pbe);

        }

        return results;
    }

// ------------------------- some convenience search methods --------------------------
    /**
     * This method provides a means of obtaining particular values of a persistent
     * object without retrieving the whole object itself. It therefore allows users
     * to obtain table column values.
     *
     * @param type the object type you want details of (must be specified)
     * @param cols the table columns (NOT attribute names) you are interested in (null
     * will retrieve all of them)
     * @return Iterator an iterator over the requested table column values - NB
     *         each item in the Iterator is of type Object, and must therefore be cast
     *         to the correct type by the user of this method. If you do not exhaust the
     *         iterator then to clean up DB resources you must pass the Iterator to the
     *         <code>closeResults</code> method of this class. Null is returned if no results found
     * @throws SearchException trhown if a problem occurs whilst searching the data store
     * @throws NullPointerException thrown if the type is null
     */
    public Iterator findColumnValues(String type, String[] cols) throws SearchException {

        if (type == null)
            throw new NullPointerException("can't query with a null type!!");
        ReportQueryByCriteria query = null;
        try {

            //empty Criteria OK, as this should result in a simple select on the cols
            query = new ReportQueryByCriteria(Class.forName(type), cols, new Criteria());
            Iterator results = myBroker.getReportQueryIteratorByQuery(query);
            return results;
        }
        catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem finding column details";
            ourLogger.info(msg);
            if (query != null) {
                ourLogger.info("class: " + query.getSearchClass().getName() + "\n");
                ourLogger.info("attribute requested: "
                        + query.getObjectProjectionAttribute() + "\n");
            }
            throw new SearchException(msg, pbe);

        }
        catch (ClassNotFoundException c) {

            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            ourLogger.info(msg);
            throw new SearchException(msg, c);


        }
    }

    /**
     * This method allows submission of a query by straight SQL string. If the string
     * is garbage then expect garbage back - no guarantees are made for the results.
     *
     * @param type the object type you want details of (must be specified)
     * @param sqlString the string to be used for the query
     * @return A Collection of search results, or empty if none found
     * @throws SearchException thrown if a problem occurs whilst searching the data store
     * @throws NullPointerException thrown if the type is null
     */
    public Collection findBySQL(String type, String sqlString) throws SearchException {

        if (type == null)
            throw new NullPointerException("can't query with a null type!!");
        Collection results = new ArrayList();
        QueryBySQL query = null;
        try {

            query = new QueryBySQL(Class.forName(type), sqlString);
            results = myBroker.getCollectionByQuery(query);
            return results;
        }
        catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem doing raw SQL string search";
            ourLogger.info(msg);
            if (query != null) {
                ourLogger.info("SQL submitted: " + query.getSql() + "\n");
            }
            throw new SearchException(msg, pbe);

        }
        catch (ClassNotFoundException c) {

            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            ourLogger.info(msg);
            throw new SearchException(msg, c);
        }
    }

    /**
     * <p>This method provides a means to obtain an Iterator for search results. This
     * can be useful if you need direct control over a result set, because OJB iterators have access to
     * result sets which may then be closed by passing the iterator back to the
     * <code>closeResults</code> method. Note that this approach will not tidy up
     * open cursors on an oracle server - the only way to do this seems to be
     * to close the connection, which is done automatically via the <code>find</code>
     * method (this is OK if oracle connection pooling is used).</p>
     *
     * @param type - the class name (ie table) to be searched
     * @param col - the parameter (column name) to search on (usually ac number or name)
     * @param val - the value of the search parameter
     * @return an Iterator over the results set - null if no results found
     * @throws NullPointerException thrown if the type is null
     * @throws SearchException -  thrown for errors during the search process, eg query problems
     */
    public Iterator iteratorFind(String type, String col, String val) throws SearchException {
        Query query = null;
        Iterator resultIterator = null;
        Class searchClass = null;

        //holds anything obtained from a locally cached class
        Collection results = new ArrayList();

        //first check the params
        if (type == null)
            throw new NullPointerException("can't search with an empty type!");
        if (col == null) {

            //no table column
            String msg = "search failed: no search parameter specified in request";
            ourLogger.info(msg);
            throw new SearchException(msg);
        }

        try {

            searchClass = Class.forName(type);
            Criteria crit = null;

            //check local cache first for the object, in case the col is not the PK
            if (isCachedClass(searchClass)) {

                ourLogger.info("search class may be unique by criteria other than PK - trying local cache...");

                Object obj = myCache.get(searchClass + "-" + col + "-" + val);

                if (obj != null) {

                    ourLogger.debug("class " + obj.getClass().getName() + " found in local cache");
                    ourLogger.debug("returning locally cached object as find result - class: " + obj.getClass().getName());
                    //as obj is unique, we are done
                    results.add(obj);
                    return results.iterator();

                }
            }

            if (val != null) {
                //fully specified search value
                crit = new Criteria();
                crit.addEqualTo(col, val);
            }
            //}
            ourLogger.info("criteria built OK");
            query = new QueryByCriteria(searchClass, crit);
            ourLogger.info("query by criteria built OK: " + type + " " + col + " " + val);

            //do it - NB can't do the PB TX thing for oracle here, as the
            //iterator is 'aware' of TXs and so committing will screw up
            //the iterator. The user has to handle it!
            resultIterator = myBroker.getIteratorByQuery(query);

        }
        catch (PersistenceBrokerException pbe) {

            //problem doing the query....
            String msg = "search failed: problem executing query";
            ourLogger.info(msg);
            ourLogger.info("Criteria: " + query.getCriteria().toString() + "\n");
            ourLogger.info("class: " + query.getSearchClass().getName() + "\n");
            throw new SearchException(msg, pbe);

        }
        catch (ClassNotFoundException c) {

            //problem finding the class to search on....
            String msg = "search failed: problem executing query - class to search not found! ";
            ourLogger.info(msg);
            throw new SearchException(msg, c);


        }

        if ((isCachedClass(searchClass)) & (!results.isEmpty())) {

            //must have a unique result that could be queried other than by PK, so cache it locally
            Iterator it = results.iterator();
            Object obj = it.next();
            if (it.hasNext()) {

                //some problem - expecting a unique result...
                throw new SearchException("search error - expecting a unique result but got more than one");
            }
            myCache.put(searchClass + "-" + col + "-" + val, obj);
        }

        return resultIterator;
    }

    public String getTableName(Class clazz) {
        ClassDescriptor cld = myBroker.getDescriptorRepository().getDescriptorFor(clazz);
        if (cld == null) {
            return null;
        }
        return cld.getFullTableName();
    }

    public int getCountByQuery(Query query) {
        return myBroker.getCount(query);
    }

    public Object getObjectByQuery(Query query) {
        return myBroker.getObjectByQuery(query);
    }

    public Collection getCollectionByQuery(Query query) {
        return myBroker.getCollectionByQuery(query);
    }
    
    public Iterator getIteratorByReportQuery(Query query) {
        return myBroker.getReportQueryIteratorByQuery(query);
    }
    
    protected Object getIdentity(Object obj) {
        Identity ident = new Identity(obj, myBroker);
        return myBroker.getObjectByIdentity(ident);
    }

//-------------------------- private helper methods ----------------------------------------

    /**
     * <p/>
     * This method builds an OJB query based on the contents of the object parameter.
     * Specifically a query is built from any non-null field, object reference or
     * collection of the object parameter.</p>
     * <p/>
     * NOTE: A query will be built from an example object as follows:
     * - only ONE example item from any of the groups fields, references or collections, is
     * needed to build a query. In some cases (eg where an m:n relation is supplied in the
     * example object) then q special query will be built, overriding any previous search criteria.
     * This is because a different query is needed in those cases, and the search result will be the same.
     * </p>
     * <p/>
     * LIMITATIONS:
     * <p/>
     * a) reference objects set within the example must have their primary key
     * attribute set
     * b) for example objects with Collections, a collection must have at least one element
     * and the element must have at least its Primary Key set
     * </p>
     *
     * @param obj The example object to search on
     * @return Query A suitable search query object
     */
    private Query buildQueryByExample(Object obj) {

        Query query = null;
        Criteria criteria = new Criteria();

        //get some info on the parameter object's OJB details....
        MetadataManager meta = MetadataManager.getInstance();
        ClassDescriptor cld = meta.getRepository().getDescriptorFor(obj.getClass());
        FieldDescriptor[] fds = cld.getFieldDescriptions();
        String objClassName = obj.getClass().getName();

        ourLogger.debug("DAO: field descriptions for object " + objClassName + " :");

        //worker variables to hold persistent fields and their values set in the example obj
        PersistentField field;
        Object value;

        //handle "simple" fields eg String, Date etc
        ourLogger.debug("field info for object " + objClassName + ":");
        for (int i = 0; i < fds.length; i++) {
            try {

                field = fds[i].getPersistentField();
                value = field.get(obj);

                ourLogger.debug("name: " + field.getName());
                ourLogger.debug("type: " + field.getType());

                if (value != null) {
                    //OK to use the field name - its mapping to a column name is handled by OJB...
                    criteria.addEqualTo(field.getName(), value);
                    ourLogger.debug("value: " + value.toString());
                }
            }
            catch (Throwable ex) {

                ourLogger.error(ex);
            }
        }

        //try object refs..
        Vector objRefs = cld.getObjectReferenceDescriptors();
        Iterator it1 = objRefs.iterator();
        ourLogger.debug("reference object details for " + objClassName + ":");

        while (it1.hasNext()) {
            ObjectReferenceDescriptor refDesc = (ObjectReferenceDescriptor) it1.next();

            ourLogger.debug("name: " + refDesc.getAttributeName());
            ourLogger.debug("type: " + refDesc.getClass().getName());

            buildObjectRefCriteria(refDesc, criteria, obj);

        }

        //try Collection fields...
        Vector collectionDescs = cld.getCollectionDescriptors();
        Iterator it = collectionDescs.iterator();
        ourLogger.debug("collection descriptor details for " + objClassName + ":");
        while (it.hasNext()) {

            //go through the collections until we find a single one
            //containing data - only one is needed to obtain the target PK we want
            CollectionDescriptor collectionDesc = (CollectionDescriptor) it.next();

            ourLogger.debug("name: " + collectionDesc.getAttributeName());
            ourLogger.debug("item type:" + collectionDesc.getItemClass().getName());
            ourLogger.debug("persistent field: " + collectionDesc.getPersistentField().getName());

            try {
                field = collectionDesc.getPersistentField();
                Collection col = (Collection) field.get(obj);

                //got a Collection - now  need to add its details to the search info..
                if ((col != null) & (!col.isEmpty())) {

                    if (collectionDesc.isMtoNRelation()) {

                        //need to get a query as there is a specific one for m:n mappings#
                        //NB can ignore any criteria supplied so far
                        query = buildMtoNQuery(cld, collectionDesc, obj);

                        //only need ONE collection example....
                        break;
                    }
                    else {

                        buildCollectionCriteria(cld, collectionDesc, criteria, obj);

                        //only need to find one entry as we can get the target PK from it
                        query = new QueryByCriteria(obj.getClass(), criteria);
                        break;
                    }
                }
            }
            catch (Throwable ex) {

                ourLogger.error(ex);
            }
        }

        if (query == null) {

            //didn't get any info from collection - so buld a query on what we have
            query = new QueryByCriteria(obj.getClass(), criteria);

        }
        return query;

    }

    /**
     * private method to handle query building based on an example object that contains
     * a non-null collection. Note that for this to be possible the collection must contain
     * at least one object which has (at least) its primary key set.
     * <p/>
     * This method handles collections which model 1:n relations only - for m:n relations
     * the method buildMtoNQuery should be used.
     *
     * @param targetDesc The Class Descriptor of the target object
     * @param collectionDesc The CollectionDescriptor for the example object
     * @param obj The example search object
     * @throws org.apache.ojb.broker.PersistenceBrokerException Thrown if there were OJB problems
     */
    private void buildCollectionCriteria(ClassDescriptor targetDesc,
                                         CollectionDescriptor collectionDesc,
                                         Criteria criteria, Object obj)
            throws PersistenceBrokerException {

        //get some basic info first
        PersistentField field = collectionDesc.getPersistentField();
        Collection collection = (Collection) field.get(obj);
        Vector inverseFkIds = collectionDesc.getForeignKeyFields();

        ourLogger.debug("search by object (collection): field in example object " + obj.getClass().getName() + " with collection is " + field.getName());


        if (inverseFkIds != null) {

            //must be: a) elements with inverse FKs (ie 1:n mappings)....
            /*
            * sketch:
            *
            * - get the FK pointing to the target obj from any non-null Collection element
            *   (if it is not set via the example obj, go to the DB for it via the element PK)
            * - build in an addEqualTo criteria for the target obj's PK
            */

            //must only be one, as we know by now the relation to the Collection is 1:n
            int inverseFkId = ((Integer) inverseFkIds.firstElement()).intValue();
            ourLogger.debug("ID of inverse foreign key is " + inverseFkId);

            //get the PK value from the FK in the example if set, or from the DB if not...
            if (collection != null) {

                Iterator it = collection.iterator();

                //only need one example element...
                if (it.hasNext()) {

                    Object element = it.next();
                    // Element must be persistable.
                    if (!isPersistent(element)) {
                        throw new PersistenceBrokerException("Found an element that isn't persistent");
                    }

                    // To get this far; element is already persistent.

                    ourLogger.debug("class of collection elements is " + element.getClass().getName());

                    //get basic info on the element and its relevant FK
                    MetadataManager meta = MetadataManager.getInstance();
                    ClassDescriptor elemDesc = meta.getRepository().getDescriptorFor(element.getClass());
                    FieldDescriptor elemFieldDesc = elemDesc.getFieldDescriptorByIndex(inverseFkId);
                    PersistentField persistentField = elemFieldDesc.getPersistentField();

                    Object val = persistentField.get(element);

                    if (val == null) {

                        ourLogger.debug("search by object (collection sub-field): no inverse key set in element....");
                        ourLogger.debug("querying DB to get the inverse key to target...");

                        //assumes collection element in example has PK set
                        Object dbElement = myBroker.getObjectByIdentity(new Identity(element, myBroker));
                        if (dbElement != null) {

                            ourLogger.debug("DB element obtained OK - collection element details:");
                            ourLogger.debug(dbElement.toString());

                            //now get the FK value...
                            val = persistentField.get(dbElement);
                        }
                        else {
                            // We shouldn't get here because we have already chekced for persistence
                            // above.
                            ourLogger.debug("error - no collection element found in DB either.");
                            ourLogger.debug("unable to build FK relationship between collection elements and target object!!");
                            throw new PersistenceBrokerException("search by object: failed to find example details in DB");
                        }
                    }

                    //now add in the criteria details...
                    FieldDescriptor[] fieldDescs = targetDesc.getPkFields();
                    if ((fieldDescs == null) || (fieldDescs.length > 1)) {

                        //a problem - should only have one PK field!!
                        ourLogger.debug("search by object (collection): target object has zero or > 1 primary key fields!!");
                        throw new PersistenceBrokerException("search by object: descriptor for class " + targetDesc.getClassOfObject().getName() + " has zero or > 1 primary keys!!");

                    }
                    String pkField = fieldDescs[0].getAttributeName();
                    criteria.addEqualTo(pkField, val);

                    ourLogger.debug("search by object (collection): searching for object of type " + targetDesc.getClassOfObject().getName() + "with details:");
                    ourLogger.debug("PK field: " + pkField);
                    ourLogger.debug("value: " + val.toString());

                }
            }

        }
        else {

            //something wrong - Collection descriptor is not 1:n or m:n, so unknown!!
            throw new PersistenceBrokerException("object search (collection): collection is not 1:n or m:n relation, and so invalid!!");
        }

    }


    /**
     * Builds a specific query for use with m:n mappings. This case must be handled differently
     * to a 1:n collection mapping as indirection tables are involved.
     *
     * @param targetDesc The Class Descriptor of the target object of the search
     * @param collectionDesc The Collection Descriptor of the m:n mapping
     * @param obj The example object to base a search on
     * @return Query A complete query containing all previous criteria plus m:n (indirection table) details
     * @throws org.apache.ojb.broker.PersistenceBrokerException Thrown if there are OJB problems
     */
    private Query buildMtoNQuery(ClassDescriptor targetDesc, CollectionDescriptor collectionDesc, Object obj) throws PersistenceBrokerException {

        //b) indierection table case (ie m:n mappings).....
        ourLogger.debug("search by object (collection): need to check indirection table...");

        Query query = null;

        //get some basic info
        PersistentField field = collectionDesc.getPersistentField();
        Collection collection = (Collection) field.get(obj);

        /*
        * sketch:
        *
        * Need to build a special m:n query with the following info:
        * - the name of the indirection table;
        * - the PK column name of the target object;
        * - the column name of the indirection table that matches the target object PK column;
        * - the PK of a single element in the collection example;
        * - the column of the indirection table matching the element PK
        *
        */

        //NB these return the column names from the indirection table as String objects
        //(undocumented in the OJB javadoc - Object[] is not very helpful!!)
        Object[] elemClassFks = collectionDesc.getFksToItemClass();
        Object[] targetClassFks = collectionDesc.getFksToThisClass();

        String indirectionTable = collectionDesc.getIndirectionTable();

        ourLogger.debug("indirection table: " + indirectionTable);
        ourLogger.debug("column name holding element PK: " + elemClassFks[0]);
        ourLogger.debug("column name holding target PK: " + targetClassFks[0]);

        if (collection != null) {

            Iterator it = collection.iterator();

            if (it.hasNext()) {

                //only need one example element as they would all relate to the same target PK..
                Object elem = it.next();
                MetadataManager meta = MetadataManager.getInstance();
                ClassDescriptor elemDesc = meta.getRepository().getDescriptorFor(elem.getClass());
                FieldDescriptor[] elemFieldDesc = elemDesc.getPkFields();

                //assume only one PK for the collection element (not unreasonable!!...)
                PersistentField pkField = elemFieldDesc[0].getPersistentField();
                Object elemPk = pkField.get(elem);

                //now build criteria to match up the element PK, indirection table and target..
                //NB ASSUMES that only one FK to an element class is defined in the Collection Descriptor
                //(which must be true - I think!)
                Criteria criteria = new Criteria();
                criteria.addEqualToColumn(indirectionTable + "." + targetClassFks[0], targetDesc.getPkFields()[0].getAttributeName());

                if (elemPk != null) {

                    ourLogger.debug("PK field for element class " + elemDesc.getClassOfObject().getName() + " : " + elemPk);
                    criteria.addEqualTo(indirectionTable + "." + (String) elemClassFks[0], elemPk);
                }
                else {

                    //must have at least the PK of the example element set, otherwise can't search...
                    throw new PersistenceBrokerException("search by object (m:n collection): collection element must have at least its Primary Key set to perofrm a search");
                }

                //now build the m:n query
                query = new QueryByMtoNCriteria(targetDesc.getClassOfObject(), indirectionTable, criteria);

            }
            else {

                //error - can't work with an empty collection...
                throw new PersistenceBrokerException("search by object (m:n collection): empty collection in search example!!");
            }

        }

        return query;

    }

    /**
     * For a search example containing an object reference, builds the appropriate
     * search criteria. Note: it is assumed that a contained object reference
     * has at least its Primary Key defined.
     *
     * @param refDesc The descriptor for the object reference
     * @param criteria The Criteria object that the result is to be added to
     * @param obj The example search object
     */
    private void buildObjectRefCriteria(ObjectReferenceDescriptor refDesc, Criteria criteria, Object obj) {

        /*
        * Sketch:
        * for each object reference of the target object that has a value set in the example,
        * - get the PK of the reference;
        * - find its corresponding FK field in the target object;
        * - build a query with a Criteria containing addEqualTo for the FK/PK pair
        *
        *
       */
        //get the value of the reference field from the example object supplied
        PersistentField field = refDesc.getPersistentField();
        Object value = field.get(obj);

        if (value != null) {

            // subqueries not supported by OJB, so can't use them -
            //need then to work with the ClassDescriptor of the reference supplied
            //in the example obj....
            MetadataManager meta = MetadataManager.getInstance();
            ClassDescriptor valueCd = meta.getRepository().getDescriptorFor(value.getClass());
            Object key = valueCd.getPrimaryKey().getPersistentField().get(value);

            //also need the FK in the target that this PK is held in..
            //the ID of the FK field can be obtained from the ObjectReferenceDescriptor
            //as a Vector of Integer - but this is likely only ever to contain one ID!!
            Vector fkIds = refDesc.getForeignKeyFields();
            if ((fkIds.size() > 1) || (fkIds.size() == 0)) {

                //something odd - reference has zero or more than one FK attribute in the target!!
                ourLogger.error("object-based search: zero or more than one FK attribute present for an object reference!!");
            }
            else {

                int fkId = ((Integer) fkIds.firstElement()).intValue();

                //now find the field in the target with this ID and compare to the PK
                ClassDescriptor cld = meta.getRepository().getDescriptorFor(obj.getClass());
                FieldDescriptor fkFieldDesc = cld.getFieldDescriptorByIndex(fkId);
                PersistentField fkField = fkFieldDesc.getPersistentField();
                criteria.addEqualTo(fkField.getName(), key);

            }

        }
    }

    /**
     * For the given class, checks whether or not it is abstract (ie it has
     * extents in OJB) and if so obtains all the CONCRETE classes that are
     * relevant to it. This enables OJB queries to be made with concrete class
     * details rather than possibly abstract ones, and so avoids any possible
     * problems with the way OJB handles abstract class queries.
     *
     * @param classToCheck The class to investigate
     * @return Collection a Collection of concrete classes - empty if nothing found
     */
    private Collection getConcreteClasses(Class classToCheck) {

        Collection result = new ArrayList();
        ClassDescriptor classDesc = getClassDescriptor(classToCheck);
        if (classDesc != null) {

            //NB if this doesn't work we could just check to see if it is abstract..
            if (!classDesc.isExtent()) {
                //concrete already - just return it
                result.add(classToCheck);
            }
            else {
                //get all of the concrete classes we can find
                Vector subClasses = classDesc.getExtentClasses();
                for (Iterator it = subClasses.iterator(); it.hasNext();) {
                    Class subClass = (Class) it.next();
                    // ClassDescriptor subClassDesc = getClassDescriptor(subClass);
                    result.addAll(getConcreteClasses(subClass));
                }

            }
        }

        return result;
    }

    /**
     * trivial method to obtain an OJB class descriptor for a given class.
     *
     * @param clazz The class we are interested in
     * @return ClassDescriptor The OJB class descriptor for that class (as specified
     *         in the repositro_user.xml configuration) - null if the descriptor does not exist
     */
    private ClassDescriptor getClassDescriptor(Class clazz) {
        MetadataManager meta = MetadataManager.getInstance();
        return (meta.getRepository().getDescriptorFor(clazz));
    }

    /**
     * Used as part of the query building process to ensure that only queries are built
     * for matching types. For '*' searches, OJB loads all rows and otherwise ignores
     * types (particularly for proxy generation) - this is incorrect behaviour for tables
     * that have more than one object mapped to them. Doing this check refines the query
     * and thus also stops OJB from loading all rows of a multi-mapped table.
     *
     * @return true if the class to be searched is in a multi-mapped table, false otherwise.
     */
    private boolean isTypeNeeded(String classToFind) {

        ClassDescriptor cld = myBroker.getDescriptorRepository().getDescriptorFor(classToFind);
        if (cld == null) return false;

        // check if there is an attribute which tells us which concrete class is to be instantiated
        FieldDescriptor concreteClassFD = cld.getFieldDescriptorByName(ClassDescriptor.OJB_CONCRETE_CLASS);

        //case where the class to search is a single object to table map -
        //in this case the descriptor will have no OJB concrete class field declared
        if (concreteClassFD == null)
            return false;
        return true;

    }

    private void printCriteria(Criteria crit) {
        System.out.println("Criteria:");
        for (Enumeration e = crit.getElements(); e.hasMoreElements();) {
            Object elem = e.nextElement();
            if (elem instanceof Criteria) {
                //sub-criteria - print them..
                System.out.println("nested criteria:");
                printCriteria((Criteria) elem);
            }
            else {
                System.out.println(elem);
            }
        }
    }

    /**
     * Helper method to analyse a Collection and get the real items from
     * the contents if they are Proxies.
     *
     * @param items The objects to check
     * @return Collection a list of full objects, or empty if no proxies found
     */
    private Collection checkProxies(Collection items) {

        Collection results = new ArrayList();
        Object obj = null;
        for (Iterator it = items.iterator(); it.hasNext();) {
            obj = it.next();
            if (VirtualProxy.class.isAssignableFrom(obj.getClass())) {
                //need to get the real object and return that instead
                results.add(((VirtualProxy) obj).getRealSubject());
            }
            else {
                //not a proxy - return it anyway
                results.add(obj);
            }
        }
        return results;

    }

    /**
     * Convenience method to add an appropriate clause to a search Criteria object.
     * Thus an equality clause is added in general, but if any wildcard characters
     * (as specified by '*' or '%') exist in the search value then a 'like' clause
     * is added instead.
     *
     * @param crit The Criteria object to which the clause should be added
     * @param column The column to seacrh on
     * @param value The value to search with - may contain '*' or '%'.
     */
    private void addSearchClause(Criteria crit, String column, String value) {
        if ((value.indexOf('*') != -1) || (value.indexOf('%') != -1)) {
            //some wildcards in the string - add a 'like' clause
            crit.addLike("upper(" + column + ")", value.toUpperCase());
        }
        else {
            //normal equality..
            crit.addEqualTo("upper(" + column + ")", value.toUpperCase());
        }
    }
}
