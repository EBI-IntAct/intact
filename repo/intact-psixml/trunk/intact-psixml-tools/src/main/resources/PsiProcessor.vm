/*
 * Copyright 2001-2007 The European Bioinformatics Institute.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ${packageName};

import java.util.*;
import java.lang.reflect.Field;
import uk.ac.ebi.intact.psixml.tools.*;
import uk.ac.ebi.intact.psixml.tools.extension.*;
import uk.ac.ebi.intact.psixml.tools.validator.*;

#foreach( $importedClass in ${mcm.importedClasses} )
import ${importedClass.name};
#end

/**
 * This class is autogenerated. DO NOT MODIFY!
 * ${artifactId}, v.${version}
 */
public class ${type} implements PsiProcessor<${modelClass.simpleName}> {

    public ${type}()
    {
        // empty constructor
    }

    public PsiProcessReport run(${modelClass.simpleName} model) throws PsiProcessException {
        ValidationReport validationReport = validate(model);
        return process(model, validationReport);
    }

    protected ValidationReport validate(${modelClass.simpleName} model) throws PsiProcessException
    {
        ValidationReportImpl validationReport = new ValidationReportImpl();

        if (model == null) {
            return validationReport;
        }

## --------------------------------------
## VAL: psi extensions - phase BEFORE_VALIDATION
## --------------------------------------
        executePsiExtensions(model, new PsiProcessReport(validationReport), Phase.BEFORE_VALIDATION);

## --------------------------------------
## VAL: null check validation
## --------------------------------------

#foreach( $fieldMetadata in ${mcm.nullValidationFields} )
#set ( $var = "model.${fieldMetadata.getterMethodName}()" )

#if ( ${fieldMetadata.failIfNull} )
     if ($var == null) {
        ValidationMessage message = new ValidationMessage(model.getClass(), "Value cannot be null: " + model.getClass()+".${fieldMetadata.field.name}", MessageType.ERROR);
        validationReport.addMessage(message);
     }
#end
#if ( ${fieldMetadata.failIfNotNull} )
     if ($var != null) {
        ValidationMessage message = new ValidationMessage(model.getClass(), "Value has to be null: " + model.getClass()+".${fieldMetadata.field.name}", MessageType.ERROR);
        validationReport.addMessage(message);
     }
#end
#end

## --------------------------------------
## VAL: validation of booleans
## --------------------------------------

#foreach( $fieldMetadata in ${mcm.booleansWithMetadata} )
#set ( $clause = "model.${fieldMetadata.getterMethodName}()" )
#if ( ${fieldMetadata.failIfTrue} )
        if ($clause) {
           ValidationMessage message = new ValidationMessage(model.getClass(), "Value has to be 'false': " + model.getClass()+".${fieldMetadata.field.name}", MessageType.ERROR);
           validationReport.addMessage(message);
        }
#end
#if ( ${fieldMetadata.failIfFalse} )
        if (!${clause}) {
           ValidationMessage message = new ValidationMessage(model.getClass(), "Value has to be 'true': " + model.getClass()+".${fieldMetadata.field.name}", MessageType.ERROR);
           validationReport.addMessage(message);
        }
#end
#end


## --------------------------------------
## VAL: validation of psi elements (not in collections)
## --------------------------------------

#foreach( $fieldMetadata in ${mcm.individuals} )
#set ( $processorVarName = "processor$velocityCount" )
#set ( $reportVarName = "subReport$velocityCount" )

        ${fieldMetadata.processorClassName} ${processorVarName} = new ${fieldMetadata.processorClassName}();
        ValidationReport ${reportVarName} = ${processorVarName}.validate(model.${fieldMetadata.getterMethodName}());
        validationReport.mergeWith($reportVarName);

#end


## --------------------------------------
## VAL: validation of names
## --------------------------------------


#foreach ( $fieldMetadata in ${mcm.names} )
#if ( ${fieldMetadata.validNamesSize} > 0 )
#set ( $namesVarName = "names$velocityCount" )
       Names $namesVarName = model.${fieldMetadata.getterMethodName}();

       if (
#foreach ( $name in ${fieldMetadata.validNames} )
           #if ( $velocityCount > 1 ) || #end
           ${namesVarName}.getShortLabel().equals("$name")
#end
       ) {
       // nothing
       } else {
            ValidationMessage message = new ValidationMessage(model.getClass(), "Name '"+${namesVarName}.getShortLabel()+"' is invalid: " + model.getClass()+".${fieldMetadata.field.name} ["+getId(model)+"]", MessageType.ERROR);
            validationReport.addMessage(message);
       }
#end
#end


## --------------------------------------
## VAL: validation of collections
## --------------------------------------

#foreach( $fieldMetadata in ${mcm.collections} )
#set ( $colVarName = "col$velocityCount" )

        Collection<${fieldMetadata.genericType.simpleName}> $colVarName = model.${fieldMetadata.getterMethodName}();

#if ( ${fieldMetadata.min} > 0 )
        if (${colVarName}.size() < ${fieldMetadata.min}) {
            ValidationMessage message = new ValidationMessage(model.getClass(), "Collection cannot have less than "+${fieldMetadata.min}+" elements (found "+${colVarName}.size()+"): " + model.getClass()+".${fieldMetadata.field.name} ["+getId(model)+"]", MessageType.ERROR);
            validationReport.addMessage(message);
        }
#end

#if ( ${fieldMetadata.max} > 0 && ${fieldMetadata.max} != 2147483647 )
        if (${colVarName}.size() > ${fieldMetadata.max}) {
    #if ( ${fieldMetadata.max} == 0 )
            ValidationMessage message = new ValidationMessage(model.getClass(), "Collection must not contain any element (found "+${colVarName}.size()+"): "+model.getClass()+".${fieldMetadata.field.name} ["+getId(model)+"]", MessageType.ERROR);
    #else
            ValidationMessage message = new ValidationMessage(model.getClass(), "Collection cannot have more than "+${fieldMetadata.max}+" elements (found "+${colVarName}.size()+"): "+model.getClass()+".${fieldMetadata.field.name}", MessageType.ERROR);
    #end
            validationReport.addMessage(message);
        }
#end

#if ( ${fieldMetadata.disabled} )
        if (!${colVarName}.isEmpty()) {
            ValidationMessage message = new ValidationMessage(model.getClass(), "Collection must not contain any element (found "+${colVarName}.size()+"): "+model.getClass()+".${fieldMetadata.field.name} ["+getId(model)+"]", MessageType.ERROR);
            validationReport.addMessage(message);
        }
#end


#if ( !${fieldMetadata.disabled} )
        for (${fieldMetadata.genericType.simpleName} elem : $colVarName) {
            ${fieldMetadata.processorClassName} processor = new ${fieldMetadata.processorClassName}();
            ValidationReport subReport = processor.validate(elem);
            validationReport.mergeWith(subReport);
        }
#end
#end


## --------------------------------------
## VAL: psi extensions - phase AFTER_VALIDATION
## --------------------------------------
        executePsiExtensions(model, new PsiProcessReport(validationReport), Phase.AFTER_VALIDATION);


        return validationReport;
    }


## --------------------------------------
## PROCESS METHOD
## --------------------------------------
    protected PsiProcessReport process(${modelClass.simpleName} model, ValidationReport validationReport) throws PsiProcessException
    {
        PsiProcessReport report = new PsiProcessReport(validationReport);

        if (model == null) {
            return report;
        }

## --------------------------------------
## PROCESS: psi extensions - phase PROCESS
## --------------------------------------
        executePsiExtensions(model, report, Phase.PROCESS);

## --------------------------------------
## PROCESS: process psi elements (not collections)
## --------------------------------------

#foreach( $fieldMetadata in ${mcm.individuals} )
#set ( $processorVarName = "processor$velocityCount" )
#set ( $reportVarName = "subReport$velocityCount" )

        ${fieldMetadata.processorClassName} ${processorVarName} = new ${fieldMetadata.processorClassName}();
        PsiProcessReport ${reportVarName} = ${processorVarName}.process(model.${fieldMetadata.getterMethodName}(), validationReport);
        report.mergeWith($reportVarName);

#end

## --------------------------------------
## PROCESS: process of collections
## --------------------------------------

#foreach( $fieldMetadata in ${mcm.collections} )
#set ( $colVarName = "col$velocityCount" )

        Collection<${fieldMetadata.genericType.simpleName}> $colVarName = model.${fieldMetadata.getterMethodName}();

        for (${fieldMetadata.genericType.simpleName} elem : $colVarName) {
            ${fieldMetadata.processorClassName} processor = new ${fieldMetadata.processorClassName}();
            PsiProcessReport subReport = processor.process(elem, validationReport);
            report.mergeWith(subReport);
        }

#end

## --------------------------------------
## PROCESS: psi extensions - phase AFTER_PROCESS
## --------------------------------------
        executePsiExtensions(model, report, Phase.AFTER_PROCESS);

        return report;
    }


    private void executePsiExtensions(Object model, PsiProcessReport report, Phase currentPhase)
                                            throws PsiProcessException {
       #if ( !${mcm.extensions.empty} )

        ExtensionContext extensionContext = new ExtensionContext(model, report, currentPhase);

        try {
#foreach( $extMethod in ${mcm.extensions} )
#set ( $extVarName = "extension$velocityCount" )
            ${extMethod.declaringClass.name} ${extVarName} = new ${extMethod.declaringClass.name}();
            extensionContext.injectIntoExtension(${extVarName});

            ExtensionExecutor.execute(extensionContext, ${extVarName}, "${extMethod.name}");

#end
        } catch (Throwable t) {
            throw new PsiProcessException("Exception executing PsiExtension", t);
        }
#else
      // no psi extensions for this object type
#end
}

    private String getId(Object element) {
        String id = "";

        try {
            Field idField = getClass().getDeclaredField("id");
            Object idObj = idField.get(element);
            if (idObj != null) {
                id = idObj.toString();
            }
        } catch (Exception e) {
            // nothing
        }

        return id;
    }

}